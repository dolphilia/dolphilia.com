# pygame.joystick

ジョイスティック、ゲームパッド、トラックボールと対話するための Pygame モジュール。

|            API            |                              説明                              |
| ------------------------- | -------------------------------------------------------------- |
| pygame.joystick.init      | ジョイスティックモジュールを初期化する。                       |
| pygame.joystick.quit      | ジョイスティックモジュールをアンイニシャライズする。           |
| pygame.joystick.get_init  | ジョイスティックモジュールが初期化されていればTrueを返します。 |
| pygame.joystick.get_count | ジョイスティックの本数を返します。                             |
| pygame.joystick.Joystick  | ジョイスティックオブジェクトを新規に作成します。               |

The joystick module manages the joystick devices on a computer. Joystick devices include trackballs and video-game-style gamepads, and the module allows the use of multiple buttons and "hats". Computers may manage multiple joysticks at a time.

Each instance of the Joystick class represents one gaming device plugged into the computer. If a gaming pad has multiple joysticks on it, then the joystick object can actually represent multiple joysticks on that single game device.

For a quick way to initialise the joystick module and get a list of Joystick instances use the following code:

pygame.joystick.init()
joysticks = [pygame.joystick.Joystick(x) for x in range(pygame.joystick.get_count())]
The following event types will be generated by the joysticks

JOYAXISMOTION JOYBALLMOTION JOYBUTTONDOWN JOYBUTTONUP JOYHATMOTION
And in pygame 2, which supports hotplugging:

JOYDEVICEADDED JOYDEVICEREMOVED
Note that in pygame 2, joysticks events use a unique "instance ID". The device index passed in the constructor to a Joystick object is not unique after devices have been added and removed. You must call Joystick.get_instance_id() to find the instance ID that was assigned to a Joystick on opening.

The event queue needs to be pumped frequently for some of the methods to work. So call one of pygame.event.get, pygame.event.wait, or pygame.event.pump regularly.

pygame.joystick.init()
Initialize the joystick module.
init() -> None
This function is called automatically by pygame.init().

It initializes the joystick module. The module must be initialized before any other functions will work.

It is safe to call this function more than once.


pygame.joystick.quit()
Uninitialize the joystick module.
quit() -> None
Uninitialize the joystick module. After you call this any existing joystick objects will no longer work.

It is safe to call this function more than once.


pygame.joystick.get_init()
Returns True if the joystick module is initialized.
get_init() -> bool
Test if the pygame.joystick.init() function has been called.


pygame.joystick.get_count()
Returns the number of joysticks.
get_count() -> count
Return the number of joystick devices on the system. The count will be 0 if there are no joysticks on the system.

When you create Joystick objects using Joystick(id), you pass an integer that must be lower than this count.


pygame.joystick.Joystick
Create a new Joystick object.
Joystick(id) -> Joystick
pygame.joystick.Joystick.init
initialize the Joystick
pygame.joystick.Joystick.quit
uninitialize the Joystick
pygame.joystick.Joystick.get_init
check if the Joystick is initialized
pygame.joystick.Joystick.get_id
get the device index (deprecated)
pygame.joystick.Joystick.get_instance_id
get the joystick instance id
pygame.joystick.Joystick.get_guid
get the joystick GUID
pygame.joystick.Joystick.get_power_level
get the approximate power status of the device
pygame.joystick.Joystick.get_name
get the Joystick system name
pygame.joystick.Joystick.get_numaxes
get the number of axes on a Joystick
pygame.joystick.Joystick.get_axis
get the current position of an axis
pygame.joystick.Joystick.get_numballs
get the number of trackballs on a Joystick
pygame.joystick.Joystick.get_ball
get the relative position of a trackball
pygame.joystick.Joystick.get_numbuttons
get the number of buttons on a Joystick
pygame.joystick.Joystick.get_button
get the current button state
pygame.joystick.Joystick.get_numhats
get the number of hat controls on a Joystick
pygame.joystick.Joystick.get_hat
get the position of a joystick hat
pygame.joystick.Joystick.rumble
Start a rumbling effect
pygame.joystick.Joystick.stop_rumble
Stop any rumble effect playing
Create a new joystick to access a physical device. The id argument must be a value from 0 to pygame.joystick.get_count() - 1.

Joysticks are initialised on creation and are shut down when deallocated. Once the device is initialized the pygame event queue will start receiving events about its input.

Changed in pygame 2.0.0: Joystick objects are now opened immediately on creation.

init()
initialize the Joystick
init() -> None
Initialize the joystick, if it has been closed. It is safe to call this even if the joystick is already initialized.

Deprecated since pygame 2.0.0: In future it will not be possible to reinitialise a closed Joystick object. Will be removed in Pygame 2.1.


quit()
uninitialize the Joystick
quit() -> None
Close a Joystick object. After this the pygame event queue will no longer receive events from the device.

It is safe to call this more than once.


get_init()
check if the Joystick is initialized
get_init() -> bool
Return True if the Joystick object is currently initialised.


get_id()
get the device index (deprecated)
get_id() -> int
Returns the original device index for this device. This is the same value that was passed to the Joystick() constructor. This method can safely be called while the Joystick is not initialized.

Deprecated since pygame 2.0.0: The original device index is not useful in pygame 2. Use get_instance_id() instead. Will be removed in Pygame 2.1.


get_instance_id() → int
get the joystick instance id
get_instance_id() -> int
Get the joystick instance ID. This matches the instance_id field that is given in joystick events.

New in pygame 2.0.0dev11.


get_guid() → str
get the joystick GUID
get_guid() -> str
Get the GUID string. This identifies the exact hardware of the joystick device.

New in pygame 2.0.0dev11.


get_power_level() → str
get the approximate power status of the device
get_power_level() -> str
Get a string giving the power status of the device.

One of: empty, low, medium, full, wired, max, or unknown.

New in pygame 2.0.0dev11.


get_name()
get the Joystick system name
get_name() -> string
Returns the system name for this joystick device. It is unknown what name the system will give to the Joystick, but it should be a unique name that identifies the device. This method can safely be called while the Joystick is not initialized.


get_numaxes()
get the number of axes on a Joystick
get_numaxes() -> int
Returns the number of input axes are on a Joystick. There will usually be two for the position. Controls like rudders and throttles are treated as additional axes.

The pygame.JOYAXISMOTION events will be in the range from -1.0 to 1.0. A value of 0.0 means the axis is centered. Gamepad devices will usually be -1, 0, or 1 with no values in between. Older analog joystick axes will not always use the full -1 to 1 range, and the centered value will be some area around 0.

Analog joysticks usually have a bit of noise in their axis, which will generate a lot of rapid small motion events.


get_axis()
get the current position of an axis
get_axis(axis_number) -> float
Returns the current position of a joystick axis. The value will range from -1 to 1 with a value of 0 being centered. You may want to take into account some tolerance to handle jitter, and joystick drift may keep the joystick from centering at 0 or using the full range of position values.

The axis number must be an integer from 0 to get_numaxes() - 1.

When using gamepads both the control sticks and the analog triggers are usually reported as axes.


get_numballs()
get the number of trackballs on a Joystick
get_numballs() -> int
Returns the number of trackball devices on a Joystick. These devices work similar to a mouse but they have no absolute position; they only have relative amounts of movement.

The pygame.JOYBALLMOTION event will be sent when the trackball is rolled. It will report the amount of movement on the trackball.


get_ball()
get the relative position of a trackball
get_ball(ball_number) -> x, y
Returns the relative movement of a joystick button. The value is a x, y pair holding the relative movement since the last call to get_ball.

The ball number must be an integer from 0 to get_numballs() - 1.


get_numbuttons()
get the number of buttons on a Joystick
get_numbuttons() -> int
Returns the number of pushable buttons on the joystick. These buttons have a boolean (on or off) state.

Buttons generate a pygame.JOYBUTTONDOWN and pygame.JOYBUTTONUP event when they are pressed and released.


get_button()
get the current button state
get_button(button) -> bool
Returns the current state of a joystick button.


get_numhats()
get the number of hat controls on a Joystick
get_numhats() -> int
Returns the number of joystick hats on a Joystick. Hat devices are like miniature digital joysticks on a joystick. Each hat has two axes of input.

The pygame.JOYHATMOTION event is generated when the hat changes position. The position attribute for the event contains a pair of values that are either -1, 0, or 1. A position of (0, 0) means the hat is centered.


get_hat()
get the position of a joystick hat
get_hat(hat_number) -> x, y
Returns the current position of a position hat. The position is given as two values representing the x and y position for the hat. (0, 0) means centered. A value of -1 means left/down and a value of 1 means right/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means up; (1, 1) means upper-right; etc.

This value is digital, i.e., each coordinate can be -1, 0 or 1 but never in-between.

The hat number must be between 0 and get_numhats() - 1.


rumble()
Start a rumbling effect
rumble(low_frequency, high_frequency, duration) -> bool
Start a rumble effect on the joystick, with the specified strength ranging from 0 to 1. Duration is length of the effect, in ms. Setting the duration to 0 will play the effect until another one overwrites it or Joystick.stop_rumble() is called. If an effect is already playing, then it will be overwritten.

Returns True if the rumble was played successfully or False if the joystick does not support it or pygame.version.SDL()tupled integers of the SDL library version is below 2.0.9.

New in pygame 2.0.2.


stop_rumble()
Stop any rumble effect playing
stop_rumble() -> None
Stops any rumble effect playing on the joystick. See Joystick.rumble() for more information.

New in pygame 2.0.2.



joystick module example
Example code for joystick module.

import pygame

pygame.init()
# This is a simple class that will help us print to the screen.
# It has nothing to do with the joysticks, just outputting the
# information.
class TextPrint:
    def __init__(self):
        self.reset()
        self.font = pygame.font.Font(None, 25)

    def tprint(self, screen, text):
        text_bitmap = self.font.render(text, True, (0, 0, 0))
        screen.blit(text_bitmap, (self.x, self.y))
        self.y += self.line_height

    def reset(self):
        self.x = 10
        self.y = 10
        self.line_height = 15

    def indent(self):
        self.x += 10

    def unindent(self):
        self.x -= 10


def main():
    # Set the width and height of the screen (width, height), and name the window.
    screen = pygame.display.set_mode((500, 700))
    pygame.display.set_caption("Joystick example")

    # Used to manage how fast the screen updates.
    clock = pygame.time.Clock()

    # Get ready to print.
    text_print = TextPrint()

    # This dict can be left as-is, since pygame will generate a
    # pygame.JOYDEVICEADDED event for every joystick connected
    # at the start of the program.
    joysticks = {}

    done = False
    while not done:
        # Event processing step.
        # Possible joystick events: JOYAXISMOTION, JOYBALLMOTION, JOYBUTTONDOWN,
        # JOYBUTTONUP, JOYHATMOTION, JOYDEVICEADDED, JOYDEVICEREMOVED
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                done = True  # Flag that we are done so we exit this loop.

            if event.type == pygame.JOYBUTTONDOWN:
                print("Joystick button pressed.")
                if event.button == 0:
                    joystick = joysticks[event.instance_id]
                    if joystick.rumble(0, 0.7, 500):
                        print(f"Rumble effect played on joystick {event.instance_id}")

            if event.type == pygame.JOYBUTTONUP:
                print("Joystick button released.")

            # Handle hotplugging
            if event.type == pygame.JOYDEVICEADDED:
                # This event will be generated when the program starts for every
                # joystick, filling up the list without needing to create them manually.
                joy = pygame.joystick.Joystick(event.device_index)
                joysticks[joy.get_instance_id()] = joy
                print(f"Joystick {joy.get_instance_id()} connencted")

            if event.type == pygame.JOYDEVICEREMOVED:
                del joysticks[event.instance_id]
                print(f"Joystick {event.instance_id} disconnected")

        # Drawing step
        # First, clear the screen to white. Don't put other drawing commands
        # above this, or they will be erased with this command.
        screen.fill((255, 255, 255))
        text_print.reset()

        # Get count of joysticks.
        joystick_count = pygame.joystick.get_count()

        text_print.tprint(screen, f"Number of joysticks: {joystick_count}")
        text_print.indent()

        # For each joystick:
        for joystick in joysticks.values():
            jid = joystick.get_instance_id()

            text_print.tprint(screen, f"Joystick {jid}")
            text_print.indent()

            # Get the name from the OS for the controller/joystick.
            name = joystick.get_name()
            text_print.tprint(screen, f"Joystick name: {name}")

            guid = joystick.get_guid()
            text_print.tprint(screen, f"GUID: {guid}")

            power_level = joystick.get_power_level()
            text_print.tprint(screen, f"Joystick's power level: {power_level}")

            # Usually axis run in pairs, up/down for one, and left/right for
            # the other. Triggers count as axes.
            axes = joystick.get_numaxes()
            text_print.tprint(screen, f"Number of axes: {axes}")
            text_print.indent()

            for i in range(axes):
                axis = joystick.get_axis(i)
                text_print.tprint(screen, f"Axis {i} value: {axis:>6.3f}")
            text_print.unindent()

            buttons = joystick.get_numbuttons()
            text_print.tprint(screen, f"Number of buttons: {buttons}")
            text_print.indent()

            for i in range(buttons):
                button = joystick.get_button(i)
                text_print.tprint(screen, f"Button {i:>2} value: {button}")
            text_print.unindent()

            hats = joystick.get_numhats()
            text_print.tprint(screen, f"Number of hats: {hats}")
            text_print.indent()

            # Hat position. All or nothing for direction, not a float like
            # get_axis(). Position is a tuple of int values (x, y).
            for i in range(hats):
                hat = joystick.get_hat(i)
                text_print.tprint(screen, f"Hat {i} value: {str(hat)}")
            text_print.unindent()

            text_print.unindent()

        # Go ahead and update the screen with what we've drawn.
        pygame.display.flip()

        # Limit to 30 frames per second.
        clock.tick(30)


if __name__ == "__main__":
    main()
    # If you forget this line, the program will 'hang'
    # on exit if running from IDLE.
    pygame.quit()
Controller mappings are drawn from the underlying SDL library which pygame uses and they differ between pygame 1 and pygame 2. Below are a couple of mappings for three popular controllers.

Axis and hat mappings are listed from -1 to +1.

Nintendo Switch Left Joy-Con (pygame 2.x)

The Nintendo Switch Left Joy-Con has 4 axes, 11 buttons, and 0 hats. The values for the 4 axes never change. The controller is recognized as "Wireless Gamepad"

Buttons:

D-pad Up        - Button 0
D-pad Down      - Button 1
D-pad Left      - Button 2
D-pad Right     - Button 3
SL              - Button 4
SR              - Button 5
-               - Button 8
Stick In        - Button 10
Capture         - Button 13
L               - Button 14
ZL              - Button 15
Hat/JoyStick:

Down -> Up      - Y Axis
Left -> Right   - X Axis
Nintendo Switch Right Joy-Con (pygame 2.x)

The Nintendo Switch Right Joy-Con has 4 axes, 11 buttons, and 0 hats. The values for the 4 axes never change. The controller is recognized as "Wireless Gamepad"

Buttons:

A Button        - Button 0
B Button        - Button 1
X Button        - Button 2
Y Button        - Button 3
SL              - Button 4
SR              - Button 5
+               - Button 9
Stick In        - Button 11
Home            - Button 12
R               - Button 14
ZR              - Button 15
Hat/JoyStick:

Down -> Up      - Y Axis
Left -> Right   - X Axis
Nintendo Switch Pro Controller (pygame 2.x)

The Nintendo Switch Pro Controller has 6 axes, 16 buttons, and 0 hats. The controller is recognized as "Nintendo Switch Pro Controller".

Left Stick:

Left -> Right   - Axis 0
Up -> Down      - Axis 1
Right Stick:

Left -> Right   - Axis 2
Up -> Down      - Axis 3
Left Trigger:

Out -> In       - Axis 4
Right Trigger:

Out -> In       - Axis 5
Buttons:

A Button        - Button 0
B Button        - Button 1
X Button        - Button 2
Y Button        - Button 3
- Button        - Button 4
Home Button     - Button 5
+ Button        - Button 6
L. Stick In     - Button 7
R. Stick In     - Button 8
Left Bumper     - Button 9
Right Bumper    - Button 10
D-pad Up        - Button 11
D-pad Down      - Button 12
D-pad Left      - Button 13
D-pad Right     - Button 14
Capture Button  - Button 15
XBox 360 Controller (pygame 2.x)

The Xbox 360 controller mapping has 6 axes, 11 buttons and 1 hat. The controller is recognized as "Xbox 360 Controller".

Left Stick:

Left -> Right   - Axis 0
Up   -> Down    - Axis 1
Right Stick:

Left -> Right   - Axis 3
Up   -> Down    - Axis 4
Left Trigger:

Out -> In       - Axis 2
Right Trigger:

Out -> In       - Axis 5
Buttons:

A Button        - Button 0
B Button        - Button 1
X Button        - Button 2
Y Button        - Button 3
Left Bumper     - Button 4
Right Bumper    - Button 5
Back Button     - Button 6
Start Button    - Button 7
L. Stick In     - Button 8
R. Stick In     - Button 9
Guide Button    - Button 10
Hat/D-pad:

Down -> Up      - Y Axis
Left -> Right   - X Axis
Playstation 4 Controller (pygame 2.x)

The PlayStation 4 controller mapping has 6 axes and 16 buttons. The controller is recognized as "PS4 Controller".

Left Stick:

Left -> Right   - Axis 0
Up   -> Down    - Axis 1
Right Stick:

Left -> Right   - Axis 2
Up   -> Down    - Axis 3
Left Trigger:

Out -> In       - Axis 4
Right Trigger:

Out -> In       - Axis 5
Buttons:

Cross Button    - Button 0
Circle Button   - Button 1
Square Button   - Button 2
Triangle Button - Button 3
Share Button    - Button 4
PS Button       - Button 5
Options Button  - Button 6
L. Stick In     - Button 7
R. Stick In     - Button 8
Left Bumper     - Button 9
Right Bumper    - Button 10
D-pad Up        - Button 11
D-pad Down      - Button 12
D-pad Left      - Button 13
D-pad Right     - Button 14
Touch Pad Click - Button 15
XBox 360 Controller (pygame 1.x)

The Xbox 360 controller mapping has 5 axes, 10 buttons, and 1 hat. The controller is recognized as "Controller (XBOX 360 For Windows)".

Left Stick:

Left -> Right   - Axis 0
Up   -> Down    - Axis 1
Right Stick:

Left -> Right   - Axis 4
Up   -> Down    - Axis 3
Left Trigger & Right Trigger:

RT -> LT        - Axis 2
Buttons:

A Button        - Button 0
B Button        - Button 1
X Button        - Button 2
Y Button        - Button 3
Left Bumper     - Button 4
Right Bumper    - Button 5
Back Button     - Button 6
Start Button    - Button 7
L. Stick In     - Button 8
R. Stick In     - Button 9
Hat/D-pad:

Down -> Up      - Y Axis
Left -> Right   - X Axis
Playstation 4 Controller (pygame 1.x)

The PlayStation 4 controller mapping has 6 axes, 14 buttons, and 1 hat. The controller is recognized as "Wireless Controller".

Left Stick:

Left -> Right   - Axis 0
Up   -> Down    - Axis 1
Right Stick:

Left -> Right   - Axis 2
Up   -> Down    - Axis 3
Left Trigger:

Out -> In       - Axis 5
Right Trigger:

Out -> In       - Axis 4
Buttons:

Cross Button    - Button 0
Circle Button   - Button 1
Square Button   - Button 2
Triangle Button - Button 3
Left Bumper     - Button 4
Right Bumper    - Button 5
L. Trigger(Full)- Button 6
R. Trigger(Full)- Button 7
Share Button    - Button 8
Options Button  - Button 9
L. Stick In     - Button 10
R. Stick In     - Button 11
PS Button       - Button 12
Touch Pad Click - Button 13
Hat/D-pad:

Down -> Up      - Y Axis
Left -> Right   - X Axis

