# LuaJITを実行する

> このドキュメントはLuaJIT 2.1向けです。バージョン固有のドキュメントについては、各gitブランチのdocディレクトリを確認してください。

LuaJITには、POSIXシステムでは`luajit`、Windowsでは`luajit.exe`と呼ばれる単一のスタンドアロン実行ファイルのみがあります。これを使って、コマンドラインから簡単なLuaステートメントや完全なLuaアプリケーションを実行できます。対話モードもあります。

## コマンドラインオプション

`luajit`スタンドアロン実行ファイルは、通常の`lua`スタンドアロン実行ファイルのわずかに修正されたバージョンです。基本的なオプションも同様にサポートされています。`luajit -h`は利用可能なオプションの短いリストを表示します。詳細についてはLuaマニュアルをご覧ください。

LuaJITにはいくつか追加のオプションがあります：

### `-b[options] input output`

このオプションはバイトコードを保存またはリストします。以下の追加オプションが受け入れられます：

- `-l` — バイトコードのみをリストします。
- `-s` — デバッグ情報を削除します（これがデフォルトです）。
- `-g` — デバッグ情報を保持します。
- `-W` — 32ビット（非GC64）バイトコードを生成します。
- `-X` — 64ビット（GC64）バイトコードを生成します。
- `-d` — 確定的な方法でバイトコードを生成します。
- `-n name` — モジュール名を設定します（デフォルト：入力名から自動検出）。
- `-t type` — 出力ファイルタイプを設定します（デフォルト：出力名から自動検出）。
- `-a arch` — オブジェクトファイルのアーキテクチャを上書きします（デフォルト：ネイティブ）。
- `-o os` — オブジェクトファイルのOSを上書きします（デフォルト：ネイティブ）。
- `-F name` — ファイル名を上書きします（デフォルト：入力ファイル名）。
- `-e chunk` — 入力としてチャンク文字列を使用します。
- `-`（ハイフン1つ）— 入力として標準入力、出力として標準出力を使用します。

出力ファイルタイプは、出力ファイル名の拡張子から自動的に検出されます：

- `c` — Cソースファイル、エクスポートされたバイトコードデータ。
- `cc` — C++ソースファイル、エクスポートされたバイトコードデータ。
- `h` — C/C++ヘッダファイル、静的バイトコードデータ。
- `obj`または`o` — オブジェクトファイル、エクスポートされたバイトコードデータ（OSおよびアーキテクチャ固有）。
- `raw`またはその他の拡張子 — 生のバイトコードファイル（ポータブル）。

::: info メモ
- バイトコードの移植性と互換性に関する情報については、`string.dump()`も参照してください。
- 生のバイトコード形式のファイルは自動的に検出され、任意のLuaソースファイルと同様にロードできます。例えば、コマンドラインから直接、または`loadfile()`、`dofile()`などで。
- アプリケーションにモジュールのバイトコードを静的に埋め込むには、オブジェクトファイルを生成し、それをアプリケーションとリンクします。
- ほとんどのELFベースのシステム（例：Linux）では、アプリケーションをリンクするときにグローバルシンボルを明示的にエクスポートする必要があります。例えば、`-Wl,-E`を使って。
- `require()`はエクスポートされたシンボル（Windowsでは*.exeまたはlua51.dll内）およびpackage.cpath内の共有ライブラリから埋め込みバイトコードデータをロードしようとします。
:::

典型的な使用例：

```sh
luajit -b test.lua test.out                 # test.outにバイトコードを保存
luajit -bg test.lua test.out                # デバッグ情報を保持して保存
luajit -be "print('hello world')" test.out  # コマンドラインスクリプトを保存

luajit -bl test.lua                         # 標準出力にリスト表示
luajit -bl test.lua test.txt                # test.txtにリスト表示
luajit -ble "print('hello world')"          # コマンドラインスクリプトをリスト表示

luajit -b test.lua test.obj                 # オブジェクトファイルを生成
# アプリケーションとリンクして、require("test")でロード
```

### `-j cmd[=arg[,arg...]]`

このオプションはLuaJIT制御コマンドを実行するか、ロード可能な拡張モジュールのいずれかをアクティベートします。コマンドは最初に`jit.*`ライブラリで検索されます。一致する関数が見つからない場合は、`jit.<cmd>`という名前のモジュールがロードされ、モジュールの`start()`関数が指定された引数（あれば）で呼び出されます。`-j`とcmdの間のスペースはオプショナルです。

利用可能なLuaJIT制御コマンドは以下の通りです：

- `-jon` — JITコンパイラをオンにします（デフォルト）。
- `-joff` — JITコンパイラをオフにし、インタープリタのみを使用します。
- `-jflush` — コンパイルされたコードのキャッシュ全体をフラッシュします。
- `-jv` — JITコンパイラの進行状況に関する詳細情報を表示します。
- `-jdump` — 様々なコンパイラステージで使用されるコードと構造をダンプします。
- `-jp` — 統合プロファイラを開始します。

`-jv`と`-jdump`コマンドはLuaで書かれた拡張モジュールです。これらは主にJITコンパイラ自体のデバッグに使用されます。オプションと出力フォーマットの説明については、ソースの先頭にあるコメントブロックを読んでください。これらはソース配布のlibディレクトリ内に存在するか、またはjitディレクトリの下にインストールされています。デフォルトでは、これはPOSIXシステム上で`/usr/local/share/luajit-XX.YY.ZZ/jit`です（XX.YY.ZZをインストールされたバージョンに置き換えてください）。

### `-O[level]`
### `-O[+]flag`, `-O-flag`
### `-Oparam=value`

このオプションは、JITコンパイラによって使用される最適化の微調整制御を可能にします。これは主にLuaJIT自体のデバッグを目的としています。JITコンパイラは非常に高速（マイクロ秒からミリ秒の範囲の話）であることに注意してください。最適化を無効にしてもそのオーバーヘッドに目に見える影響はありませんが、通常は実行速度が遅くなるコードを生成します。

最初の形式は最適化レベルを設定します。これにより、特定の最適化フラグのミックスが有効になります。-O0はすべての最適化をオフにし、より高い数字はより多くの最適化を有効にします。レベルを省略する（つまり-Oのみ）と、現在のバージョンでのデフォルトの最適化レベル（-O3）が設定されます。

二番目の形式は個々の最適化フラグを追加または削除します。三番目の形式はVMまたはJITコンパイラのパラメータを特定の値に設定します。

このオプションを複数回使用することも（例：-Ocse -O-dce -Ohotloop=10）、複数の設定をコンマで区切ることもできます（例：-O+cse,-dce,hotloop=10）。設定は左から右に適用され、後の設定は前のものを上書きします。三つの形式を自由に組み合わせることができますが、最適化レベルを設定すると、以前のすべてのフラグが上書きされることに注意してください。

-Ofmaは、浮動小数点の結果の精度に影響を与えるため、どのレベルでもデフォルトでは有効になっていません。性能（向上）、決定性（低下）、数値精度（向上）のトレードオフを完全に理解している場合のみ、これを有効にしてください。

利用可能なフラグとその最適化レベルの有効化状況は以下の通りです：

|フラグ|-O1|-O2|-O3|
|---|---|---|---|
|fold|•|•|•|定数折りたたみ、単純化および再結合|
|cse|•|•|•|共通部分式除去|
|dce|•|•|•|デッドコード除去|
|narrow||•|•|数値の整数への縮小|
|loop||•|•|ループ最適化（コードの巻き上げ）|
|fwd|||•|ロードフォワーディング（L2L）およびストアフォワーディング（S2L）|
|dse|||•|デッドストア除去|
|abc|||•|配列境界チェック除去|
|sink|||•|割り当て/ストアシンキング|
|fuse|||•|オペランドの命令への融合|
|fma||||融合乗算加算|

パラメータとそのデフォルト設定は以下の通りです：

|パラメータ|デフォルト||
|---|---|---|
|maxtrace|1000|キャッシュ内のトレースの最大数|
|maxrecord|4000|記録されたIR命令の最大数|
|maxirconst|500|トレースのIR定数の最大数|
|maxside|100|ルートトレースのサイドトレースの最大数|
|maxsnap|500|トレースのスナップショットの最大数|
|hotloop|56|ホットループまたはホットコールを検出するための反復回数|
|hotexit|10|サイドトレースを開始するために取られた終了の回数|
|tryside|4|サイドトレースをコンパイルするための試行回数|
|instunroll|4|不安定なループの最大展開係数|
|loopunroll|15|サイドトレース内のループ演算の最大展開係数|
|callunroll|3|疑似再帰呼び出しの最大展開係数|
|recunroll|2|真の再帰のための最小展開係数|
|sizemcode|32|各マシンコード領域のサイズ（Kバイト）（Windows: 64K）|
|maxmcode|512|すべてのマシンコード領域の最大合計サイズ（Kバイト）|
