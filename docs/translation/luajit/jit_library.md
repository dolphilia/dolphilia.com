# jit.* ライブラリ

この組み込みモジュールの関数は、JITコンパイラエンジンの動作を制御します。JITコンパイルは完全に自動であることに注意してください — 特別なニーズがない限り、次に挙げる関数を使用する必要はほとんどないでしょう。

#### jit.on()
#### jit.off()

JITコンパイラをオン（デフォルト）またはオフにします。
これらの関数は通常、コマンドラインオプション -j on や -j off と共に使用されます。

#### jit.flush()

コンパイルされたコードのキャッシュ全体をフラッシュします。

#### `jit.on(func|true [,true|false])`
#### `jit.off(func|true [,true|false])`
#### `jit.flush(func|true [,true|false])`

jit.on は Lua 関数の JIT コンパイルを有効にします（これがデフォルトです）。

jit.off は Lua 関数の JIT コンパイルを無効にし、コードキャッシュから既にコンパイルされたコードをフラッシュします。

jit.flush はコードをフラッシュしますが、有効/無効の状態には影響しません。

現在の関数、つまりこのライブラリ関数を呼び出す Lua 関数は、最初の引数に true を指定することで指定することもできます。

第二引数に true が指定されている場合、関数のすべてのサブ関数に対しても JIT コンパイルが再帰的に有効化、無効化またはフラッシュされます。false が指定されている場合は、サブ関数のみが影響を受けます。

jit.on と jit.off 関数は、関数がコンパイルされようとするときにチェックされるフラグを設定するだけで、即時のコンパイルをトリガーしません。

典型的な使用例は、デバッグ目的でモジュール全体の JIT コンパイルをオフにするために、モジュールのメインチャンクで jit.off(true, true) を使用することです。

#### `jit.flush(tr)`

キャッシュから指定された番号のルートトレースとそのすべてのサイドトレースをフラッシュします。トレースにリンクしている他のトレースがある限り、トレースのコードは保持されます。

#### status, ... = jit.status()

JIT コンパイラの現在の状態を返します。最初の結果は JIT コンパイラがオンかオフかを示す true または false です。残りの結果は CPU 固有の機能と有効な最適化に関する文字列です。

#### jit.version

LuaJITのバージョン文字列を含みます。

#### jit.version_num

LuaJITコアのバージョン番号を含みます。バージョンxx.yy.zzは、十進数xxyyzzによって表されます。

ローリングリリースへの切り替え後に非推奨。zzは99で固定されます。

#### jit.os

対象のOS名を含みます：「Windows」、「Linux」、「OSX」、「BSD」、「POSIX」、「Other」。

#### jit.arch

対象のアーキテクチャ名を含みます：「x86」、「x64」、「arm」、「arm64」、「arm64be」、「ppc」、「mips」、「mipsel」、「mips64」、「mips64el」、「mips64r6」、「mips64r6el」。

## jit.opt.* — JITコンパイラ最適化制御

このサブモジュールは、-Oコマンドラインオプションのバックエンドを提供します。
プログラム的にも使用できます。例えば：

```lua
jit.opt.start(2) -- -O2と同じ
jit.opt.start("-dce")
jit.opt.start("hotloop=10", "hotexit=2")
```

LuaJIT 1.xとは異なり、このモジュールは組み込まれており、最適化はデフォルトでオンになっています！最適化を有効にする方法の一つであったrequire("jit.opt").start()を実行する必要はもうありません。

## jit.util.* — JITコンパイラ内省

このサブモジュールは、バイトコード、生成されたトレース、IR、および生成されたマシンコードを内省するための関数を保持しています。このモジュールによって提供される機能はまだ変更中であり、そのため文書化されていません。

デバッグモジュール-jbc、-jv、および-jdumpは、これらの関数を広範囲に使用します。もっと知りたい場合は、それらのソースコードを確認してください。