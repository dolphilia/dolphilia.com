# Duktapeデバッガ

## はじめに

### 概要

Duktapeには、以下の基本的なデバッグ機能があります。

- 実行状況：ファイル/ラインでの実行/一時停止、コールスタック、ローカル変数
- 実行制御：一時停止、再開、ステップオーバー、ステップイン、ステップアウト
- ブレークポイント：対象となるファイル/行のペア、ブレークポイントリスト、"debugger "ステートメント
- 一時停止中にコールスタック上の任意の活性化のコンテキストで評価（基本的なウォッチ式の実装に使用可能）
- 内部メタデータ、プロパティを列挙してヒープオブジェクトを検査し、プロトタイプチェーンを歩く
- 任意のコールスタックレベルで変数を取得/配置する。
- アプリケーション定義のリクエスト（AppRequest）および通知（AppNotify）のためのメカニズム
- ロガーの書き込みを転送する
- ヒープフルダンプ（デバッガーのウェブUIでJSONに変換される）

Duktapeのデバッグ・アーキテクチャは、以下の主要な部分から構成されています。

- Duktapeが直接実装する標準的な**デバッグ・プロトコル**です。
- アプリケーションによって実装される、信頼性の高い **デバッグトランスポート** ストリーム。
- Duktapeヒープにデバッガをアタッチ/デタッチするための**デバッグAPI**です。
- デバッグプロトコルエンドポイントを実装し、ユーザーインターフェースを提供する、オフターゲットで動作する**デバッグクライアント**である。
- オプションの **JSON デバッグプロトコルプロキシ** は、デバッグターゲットと対話するための、より簡単なJSONベースのインターフェイスを提供します。  Node.jsとDukLuvで書かれたプロキシ実装の例がDuktapeに含まれています。

本書では、これらの作品について詳しく説明します。

### はじめに："duk "を使ったデバッグについて

デバッグターゲットとして `duk --debugger` を、デバッグクライアントとして `debugger/duk_debug.js` を使用する具体的な方法については `debugger/README.rst` を参照してください。

### はじめに：ターゲットのデバッグ

ターゲットにデバッガサポートを組み込むには、以下のことが必要です。

- **設定オプションの確認**: Duktape のデバッガーサポートを有効にするには、`DUK_USE_DEBUGGER_SUPPORT` と `DUK_USE_INTERRUPT_COUNTER` を有効にしてください。また、その他のデバッグ関連のコンフィグオプションも考慮してください。
- **具体的なストリーム伝送機構を実装する**: ターゲット・デバイスとDuktapeデバッガの両方に必要です。  最適なトランスポートはターゲットに依存します。例えば、TCP ソケット、 シリアルリンク、あるいは既存のカスタムプロトコルにデバッグデータを埋め込む、などです。  TCP デバッグトランスポートの例は `examples/debug-trans-socket/duk_trans_socket_unix.c` で提供されています。
- **デバッガを添付するコードの追加**: はデバッグを開始する時に `duk_debugger_attach()` を呼び出します。Duktapeは実行を一時停止し、デバッグメッセージを処理します(必要ならブロッ キングします)。  実行はデバッグクライアントの制御下で再開されます。
- **終了後、デバッガをデタッチします**: デバッグを停止するには `duk_debugger_detach()` を呼び出します。デバッグストリームエラーも自動的に切り離されます。  デバッグストリームエラーが発生すると、Duktapeは通常の実行を再開し、ブレークポイントなどを無視します(デバッグクライアントから明示的に要求された場合やDuktapeがデバッグストリームエラーを検出した場合にもデタッチが発生することがあります。)。
- **イベントループがある場合**: オプションで、Duktape の呼び出しが行われていない時に、たまに `duk_debugger_cooperate()` を呼び出します。  これにより、デバッグコマンドを Duktape の呼び出しの外で実行することができるようになります。

Duktapeには、プレーンなTCPトランスポートをサポートするデバッグ・クライアントが付属しています。また、サードパーティ製のデバッグクライアントもいくつかあり、ターゲットと通信できるようにすることができます。これらは同じデバッグプロトコルを共有しているので、トランスポートだけを適合させる必要があります。

また、デバッグプロトコルのクライアント側を実装することで、独自のデバッグクライアントを作成することもできます。  デバッグ・クライアントはターゲットのデバッグ・プロトコルのバージョンに適応するよう意図されているので、Duktapeデバッグ・プロトコルの進化に伴って、デバッグ・クライアントの変更が必要になる場合があります。  デバッグ・プロトコルは、Duktape APIと同じセマンティック・バージョニングの原則でバージョン管理されています。

バイナリー・デバッグ・プロトコルをデバッグ・クライアントに直接実装することもできますが、より簡単な方法として、デバッグ・プロトコルのJSONマッピングを使用すると、より使い勝手が良くなります。  Duktapeには、JSONマッピングと、ターゲット上で実際に動作するバイナリー・デバッグ・プロトコルを変換するプロキシサーバーが含まれています。

### クライアントとサーバーのデバッグ例

Duktapeレポには、デバッグ・トランスポートにTCPを使用し、Duktapeコマンドライン・ツール（「duk」）と通信できるデバッガーのウェブUIの例が含まれています。  この実行例は、デバッグコマンドの具体的な詳細とデバッグトランスポートの実装方法をさらに文書化するためのものです。  ウェブコンソールは、TCPデバッグトランスポートを使用する他のデバッグターゲットと直接対話することも可能です。

デバッガーのサンプルには:

* Duktapeのコマンドラインツールの `--debugger` オプションは、 `DUK_CMDLINE_DEBUGGER_SUPPORT` と `DUK_USE_DEBUGGER_SUPPORT` の両方を使用することで有効にすることができます。コマンドラインツールは `examples/debug-trans-socket/` で提供される TCP ソケットベースのサンプルトランスポートを使用します。

* NodeJS + ExpressJS ベースの最小デバッガー Web UI が `debugger/` ディレクトリにあり、デバッグ転送に TCP ソケットを使用します。

**TCPは良い例のトランスポートではあるが、「標準」トランスポートではない。トランスポートは常に最終的にはユーザーコード次第である。**

### ローカルデバッガの例

通常、リモート・デバッグ・クライアントが望ましいのですが、場合によってはDuktapeが動作しているのと同じプロセスでデバッグ接続を終了させるのが便利なことがあります。  Duktapeの観点からは、「ローカル」デバッガはリモートのデバッガと同じです：デバッグ・トランスポートの実装がDuktapeとの違いを隠してくれます。ローカルなd値エンコーダー/デコーダーを持つデバッグ・トランスポートの例があります。

- `examples/debug-trans-dvalue/`

サンプルのトランスポートは、dvalueのエンコードとデコードの詳細を隠し、ローカルのデバッグクライアントを書きやすくします。  このトランスポートは、C言語でdvalueを扱う例としても役立ちます（Node.jsのデバッガには、Javascriptのための同様の例があります）。

### Duktapeが提供しないもの

#### 標準的なデバッグ用トランスポート

最適なトランスポートは千差万別なので、これはユーザーコード次第です。Wi-Fi、シリアルポート、などなど。  しかし、TCP を使用しない特別な理由がないのであれば、おそらく TCP は良いデフォルトのトランスポートとなるでしょう。  バンドルされているサンプルのデバッガー Web UI と JSON デバッグプロキシは、トランスポートとして TCP を使用します。

#### 標準的なデバッガーUI

ユーザー・コードは、Duktapeがサポートするデバッグ・コマンドの上に、具体的なデバッガー・インターフェイスを実装する必要があります。  しかし、Duktapeには、完全に機能するデバッガの例が含まれています。  必要に応じてこれを拡張することもできますし、自分で書くこともできます。

#### 機能ソースコード

Duktapeは現在、デバッグ・プロトコルで関数のソース・コードを提供していません。  デバッグクライアントは、一致するソースコードにアクセスでき、特定のファイル名に一致するソースファイルを見つける能力を持っていることが前提です。  これは、`eval` を使って作成された関数は、ソースが存在する状態でデバッグできないことも意味します。


## デバッガサポート有効化の影響

### パフォーマンス

デバッガが接続され、実行中の関数にアクティブなブレークポイントがある場合を除き、パフォーマンスへの影響は非常に小さいはずです。

バイトコードエクゼキュータが再起動するとき、デバッガが接続されていないことをすぐに判断し、ブレークポイントを処理する必要はありません。  バイトコード実行に何らかの影響を与えるデバッガを使用するには、バイトコードエクゼキュータ割り込みを有効にする必要があります。

Duktapeは、デバッガが接続され、現在の関数にアクティブなブレークポイントがある場合、「チェック済み実行」になります。  チェック実行（詳細は後述）は、通常の実行よりはるかに遅く、バイトコード命令ごとに割り込みハンドラが実行されます。

### コードフットプリント

デバッガサポートにより、フットプリントが約15-20kB増加します（有効なデバッガ機能に依存）。
デバッガ機能が有効な場合

### メモリフットプリント

ヒープレベルのデバッガー状態のため、 `duk_heap` 構造体のサイズが増加します。細かく調整されたメモリプールを使用している場合、メモリプールのサイズを再チューニングする必要があるかもしれません。

関数インスタンスは常に内部の `_Varmap` プロパティを保持し、ローカル変数が常に名前で検索できるようにします。  デバッガのサポートがない場合、 `_Varmap` は実行中に必要となる場合のみ保持されます (例: 関数に eval コールが含まれている場合など)。

そうでなければ、メモリフットプリントは無視できるほど小さくなるはずです。  Duktape はデバッグ・メッセージのバッファリングを維持する必要がありません。なぜなら、全てのデバッグ・データはストリームで入出力されるからです。

### セキュリティ

デバッガープロトコル経由で利用可能なデバッグコマンドは、潜在的に悪用可能なメモリ安全でない動作をトリガーするために（誤って）使用される可能性があります。  たとえば、デバッグクライアントは、悪用される可能性のあるファブリケーションポインタから/への読み取り/書き込みを行う可能性があります。

これがセキュリティ上の懸念である場合、デバッグトランスポートは認証、暗号化、および完全性保護を提供する必要があります。  例えば、相互認証されたTLS接続を使用することができます。  Duktape自体は、トランスポートによって提供される以上のセキュリティ対策を提供しません。

## デバッグAPI

### duk_debugger_attach()

アプリケーションがDuktapeヒープにデバッガーを取り付けたいときに呼び出されます::

```c
duk_debugger_attach(ctx,
                    my_trans_read_cb,         /* 読み取りコールバック */
                    my_trans_write_cb,        /* 書き込みコールバック */
                    my_trans_peek_cb,         /* ピークコールバック (オプション) */
                    my_trans_read_flush_cb,   /* 読み取りフラッシュコールバック (オプション) */
                    my_trans_write_flush_cb,  /* 書き込みフラッシュコールバック (オプション) */
                    my_request_cb,            /* アプリリクエストコールバック (オプション) */
                    my_detached_cb,           /* デバッガデタッチドコールバック */
                    my_udata);                /* デバッグudata */
```

呼び出されると、Duktapeはデバッグ・モードに入り、実行を一時停止し、デバッグ・クライアントからのさらなる指示を待ちます。  Duktapeのデバッガ・サポートが有効でない場合、エラーがスローされます。

トランスポートコールバックは、開始要求の一部として与えられる。  Duktape はデバッグの開始/停止サイクルごとに新しい仮想ストリームを期待し、 `duk_debugger_attach()` が呼ばれるたびにプロトコルバージョン識別子を送信します。

detached コールバックはデバッガが切り離されたときに呼び出されます。  これは、明示的な要求 (`duk_debugger_detach()`) やデバッグメッセージ/トランスポートエラー、Duktape ヒープの破壊によって起こります。

APIドキュメントに明示的に記載されていない限り、どのコールバックもDuktape APIを呼び出すことはできません(ほとんどの場合、 `ctx` 引数を取得しないのもこのためです)。そうすると、メモリが安全でない挙動を引き起こす可能性があります。  具体的な例として、もしユーザーの読み出しコールバックが読み出し中に Duktape API を呼び出すと、その API 呼び出しがガベージコレクションの引き金になる可能性があります。  ガベージコレクションは任意の副作用を持つ可能性があるため、実行中のデバッガコマンド (`src-input/duk_debugger.c` で実装) が非常に混乱した方法でブレークする可能性があります。


### duk_debugger_detach()

アプリケーションがデバッガーをデタッチしたいときに呼び出されます::

```c
duk_debugger_detach(ctx);
```

デバッガが切り離されると、Duktapeは通常の実行を再開します。  残っているデバッグ状態（ブレークポイントなど）は無視されます。

Duktapeのデバッガ・サポートが有効でない場合、エラーが投げられます。


### duk_debugger_cooperate()

Duktapeへの呼び出しがアクティブでない場合に、受信デバッグ・コマンドを処理するためのオプションの呼び出しです。

```c
duk_debugger_cooperate(ctx);
```

保留中のデバッグコマンドは `ctx` スレッドのコンテキスト内で実行されます。ブロックせずに実行できるすべてのデバッグコマンドは、呼び出しの間に実行されます。  この呼び出しはブロックしないので、イベントループの中に埋め込んでも安全です。  この呼び出しは、デバッグがサポートされていないときやアクティブでないときは無意味なので、デバッグの状態をチェックせずに呼び出すことができます。

注意点：

- 呼び出し元は、Duktapeへの呼び出しがアクティブなときに、このAPI関数を呼び出さないようにする責任があります（どのようなコンテキストでも）。
- duk_debugger_cooperate() の呼び出しの間隔は、保留中のデバッグ・コマンドに対する Duktape の反応速度に影響します。

このAPIコールは、Duktapeへの呼び出しがアクティブでないときにEvalなどのデバッグ・コマンドを実行できるようにするために、一部のアプリケーションで必要とされています。  例えば、以下のようになります。

```c
for (;;) {
    /* イベントまたはタイムアウトを待ちます。 */
    wait_for_events_or_timeout();
    /* プロセスイベント。 */
    if (event1) {
        ...
    }
    /*...*/
    /* Duktapeデバッガと連携する。 */
    duk_debugger_cooperate(ctx);
}
```

このAPIコールは、保留中の受信メッセージをすべて処理するため（ブロックせずに利用可能）、次のように使用することも可能です。

```c
for (;;) {
    /* イベントまたはタイムアウトを待ちます。 */
    wait_for_events_or_timeout();
    /* プロセスイベント。 */
    if (got_inbound_debugger_data) {
        /* Duktapeデバッガと協力：新しい受信データが到着するまで、保留中のメッセージをすべて処理する。 */
        duk_debugger_cooperate(ctx);
    }
    /*...*/
}
```

### duk_debugger_pause()

ターゲットはいつでもこれを呼び出して、ECMAScript の実行を一時停止し、添付のデバッグクライアントに制御を移すよう要求することができます。

```c
    duk_debugger_pause(ctx);
```

要求された一時停止はすぐには起こらないかもしれませんが、次のバイトコードオペレーションディスパッチで実行されます。詳細はAPIドキュメントを参照してください。

このコールの一般的な使用例は、ホットキーにバインドすることで、ユーザーが無限ループから抜け出し、デバッグすることを可能にします。  しかし、他のDuktape APIコールと同様に、このコールはスレッドセーフではないので、デバッグ対象のECMAScriptコードを実行するために使用するのと同じスレッドから呼び出す必要があります。


### duk_debugger_notify()

デバッグトランスポートを通じてアプリケーション固有の通知を送信するためのオプションのコール::

```c
    duk_bool_t sent;

    duk_push_string(ctx, "BatteryLevel");
    duk_push_uint(ctx, 130);  /* 130 of 1000 */
    sent = duk_debugger_notify(ctx, 2 /*nvalues*/);
    /* 'sent' は、notify が正常に送信されたか否かを示す。 */
```

この呼び出しは0を返し、デバッガサポートがコンパイルされていないときや、デバッガが接続されていないときは事実上無視されます。

詳細については、以下の「カスタムリクエストと通知」を参照してください。

## デバッグトランスポート

### 概要

Duktapeのデバッガ・コードは、TCPコネクションやシリアル・リンクに似たセマンティクスを持つ、抽象化された信頼性の高いストリーム・トランスポートを介してデバッグ・メッセージを送受信します。  異なる環境への移植性を最大化するために、Duktapeはユーザーコードが `duk_debugger_attach()` に与えるコールバックという形で、このトランスポートの具体的な実装を提供することを期待しています。

トランスポートが提供する論理的なサービスは、以下のプリミティブを持つ信頼性の高いバイトストリームである。

- バイト読み（部分読みOK，最低1バイト読みが必要ならブロック）
- バイト書き込み（部分書き込みOK，最低1バイトの書き込みが必要な場合はブロックする）
- ブロッキングせずに受信バイトをPeekする。
- フラッシュヒントを読む
- 書き込みフラッシュヒント

トランスポート・コールバックの実装をできるだけ簡単にするために、部分的な 読み書きを許可しています。  Duktapeは、必要な回数だけreadとwriteを呼び出すことで、「完全に読む」「完全に書く」セマンティクスを自動的に処理します。

Peekingは、Duktapeがブロックすることなく、受信したデバッグ・メッセージを検出することを可能にします。これにより、Duktapeが（一時停止状態ではなく）通常通り動作している場合でも、デバッグ・メッセージを処理することができます。

書き込みフラッシュは、トランスポート実装が書き込みを確実に合体させることを可能にする。リードフラッシュは、トランスポート実装が受信ウィンドウをより効率的に管理 することを可能にする。  読み取り/書き込みフラッシュコールバックは、いくつかのタイプのトランスポートに おいてのみ必要とされる。

このセクションでは、各コールバックの詳細なセマンティクスをカバーし、フロー制御、圧縮、セキュリティなどの他のトランスポート関連の一般的な問題について議論しています。

**重要：アプリケーションは read/write チャンクバウンダリに何の意味も持たせるべきではありません。  リード、ライト、ピーキング、フラッシュコールがデバッグメッセージの境界に対応する保証はありません。**

### コールバックのセマンティクスを読み取る

- 読み取り長は≧1が保証される。
- バッファポインタは非NULLであることが保証される。
- Duktapeは、少なくとも1バイト、最大でも「長さ」バイトの読み取りを要求しています。  部分的な読み出しはOKだが、少なくとも1バイトは読み出さなければならない。  ユーザーコードが少なくとも1バイトを読み取れない場合、読み取れるまでブロックしなければならない(MUST)。  1バイト以上が利用可能な場合、ユーザーコードはブロックしてはならない(MUST NOT)。
- 1,length]の範囲の戻り値は、与えられたバッファにいくつのバイトが読み込まれたかを示す。
- 戻り値0は、ストリーム・エラー（サニティ・タイムアウト、コネクション・クローズなど）を示します。  Duktapeはそのストリームを壊れたとみなし、それ以上操作を行いません。  デバッガは自動的に切り離されます。

### コールバックのセマンティクスを書き込む

- 書き込み長は≧1であることが保証される。
- バッファポインタは非NULLであることが保証される。
- Duktapeは、最低でも1バイト、最大でも「length」バイトの書き込みを要求しています。  部分的な書き込みはOKだが、少なくとも1バイトは書き込まなければならない。もしユーザー・コードが少なくとも1バイトを書き込めない場合は、書き込めるようになるまでブロックしなければならない（MUST）。
- 1,length]の範囲の戻り値は、与えられたバッファから何バイトが書き込まれたかを示します。
- 戻り値0は、ストリーム・エラー（サニティ・タイムアウト、コネクション・クローズなど）を示します。  Duktapeはそのストリームを壊れたとみなし、それ以上操作を行いません。  デバッガは自動的に切り離されます。

### Peekコールバックのセマンティクス

- peekコールバックの実装はオプションです(NULLは `duk_debugger_attach()` で渡すことができます)が、強く推奨します。  コールバックが提供されない場合、(Duktapeが正常に動作している間に)「突然」実行を一時停止するようないくつかの機能は動作しなくなります。
- Peekコールバックには引数がありません。
- Duktapeは入力ストリームを覗くことを要求しています。つまり、少なくとも1バイトがブロックされずに読み込めるかどうかを確認するためです。
- 戻り値0は、ブロックせずに読み取ることができるバイトがないことを示す。
- 戻り値 > 0 は、ブロッキングせずに読み込めるバイト数を示します。  現在、Duktapeは少なくとも1バイトが利用可能かどうかだけを気にしているので、 0か1を返せば十分です。
- Duktapeは現在、少なくとも1バイトが利用可能であれば、デバッグメッセージ全体を読み取ることができると仮定しています（必要に応じてブロックし、部分的な読み取りを処理します）。

### リードフラッシュコールバックのセマンティクス

* リードフラッシュコールバックの実装はオプションです (`duk_debugger_attach()` で NULL を渡すことができます)。
* リードフラッシュコールバックは引数を持たない。
* Duktapeはユーザー・コードに対して「リード・フラッシュ」を指示しています。  Duktapeは、その場ではもう読み込みをしないかもしれないのに、"read flush "を指示することが保証されています。  (ただし、Duktapeはその直後から読み込みを続けていても、読み込みのフラッシュを示すことがあります)。
* ほとんどのトランスポートでは、リードフラッシュは重要ではない。  トランスポートプロトコルが制限された読み取りウィンドウを使用し、リ モートピアにウィンドウの状態を更新するプロトコルを持つ場合、ウィンドウ 制御メッセージは次の読み取りフラッシュに延期できる(読み取りバッファが空の状態 など、それを送信する他の緊急の理由がない場合)。

### 書き込みフラッシュコールバックセマンティクス

* 書き込みフラッシュコールバックの実装はオプションです (`duk_debugger_attach()` で NULL を渡すことができます)。
* 書き込みフラッシュコールバックは引数を持ちません。
* Duktapeは、ユーザーコードに対して「書き込みフラッシュ」を示しています。  Duktapeは、その特定の機会にこれ以上書き込みをしないかもしれないとき、 「書き込みフラッシュ」を示すことが保証されています。  (ただし、Duktapeは書き込みの直後でも書き込みフラッシュを指示することが あります)。
* この表示は、ユーザー・トランスポートが書き込みをより大きなチャンクにまと める場合に有用です。  ユーザーコードは、バッファリングされたデータが十分に大きくなるか、書き込みフラッシ ュが指示されると、チャンクを送り出すことができます。  ユーザーコードは、重要なときにライトフラッシュが起こることを信頼することができる。
* ユーザーコードは、この表示が基礎となるトランスポートに適用されない場合（例えば、TCPを使用する場合、書き込みの自動合体のためのメカニズムがすでにあります）、または保留中のバイトが最終的に送信されることを確実にするための他のメカニズム（例えば、タイマー）がある場合、無視する自由もあります。

### トランスポートが壊れたことを示すマーク

Duktapeは、次の場合に輸送が壊れたとマークします。

* ユーザー・コールバックがストリーム・エラーを示した場合
* Duktapeがデバッグ・ストリームをパースする際に、パース・エラーに遭遇した場合。

デバッグ・トランスポートが壊れたとマークされたとき。

* デバッガは自動的に切り離され、通常のECMAScriptの実行が直ちに再開されます。  デタッチド コールバックが存在する場合は、それが呼び出されます。
* Duktapeは、ストリームのユーザー・コールバックに対して、これ以上呼び出しを行いません。
* Duktape内部のデバッグ用読み込みコールは、ダミー値（バイト読み込み時は0、整数読み込み時は0、文字列読み込み時は空文字列など）を返し、書き込みは黙って無視されます。  これにより、実装は読み書きのたびにエラーをチェックすることなくデータの読み書きができます。「壊れたトランスポート」に対する明示的なチェックは、最も便利な場所で行うことができます。

### ピーキングリクエストノート

Duktapeは、入ってくるデバッグ・コマンドを検出し、それを処理するためにピー ク・リクエストを使用します。ピー クは、通常の実行時 (関連するブレークポイントがなく、ステッピングがアクティブでない時) と チェック実行時 (1つ以上のアクティブなブレークポイントがあり、ステッピングがアクティブな時) の両方に使用されます。

Duktapeは、日付ベースのタイムスタンプを使用して、ピーク要求のレートを自動的に制限しています。

### フラッシュ・ノートの作成

Duktapeは、書き込みフラッシュを使用して、この機会にこれ以上データを送信しない可能性があること、および、アプリケーションがキューに入れた保留データを送信する必要があることを示します。

Duktapeは、送信するデバッグ・メッセージを非常に小さく分割して書き込むので、アプリケーションが送信待ちデータのバッファを維持するのは理にかなっているかもしれません。Duktapeが書き込みを行う際、データをバッファに追加することができます。  データは、バッファが十分に大きくなった時か、Duktapeが書き込みフラッシュを実行した時に送出されます。

書き込みフラッシュは、Duktapeがメッセージのセットを処理し終わった時に発生するこ とが保証されており、アプリケーションは、保留中の書き込みをフラッシュするための タイマー・メカニズムなどを別に持つ必要がありません。  書き込みフラッシュは、送信されるデバッグ・メッセージの後では保証され ません（現在のDuktapeの実装はそのように動作しますが）。

** ユーザー・コードは、Duktapeがいつ書き込みフラッシュを示すかについて、それが起こったときに保留中のバイトを送信すること以外、何も仮定してはいけません **

### 信頼性

Duktapeは、トランスポートが信頼できるものであることを期待します。すなわち、 バイトの並び替えや紛失、重複がないことです。  具体的なトランスポートは、アプリケーション固有の手段で信頼性を提供しな ければならない。  例えば、TCP ソケットが使われる場合、信頼性は TCP によって自動的に提供されます。  信頼性のないパケットトランスポートの場合、ユーザコードは再送、重複検出、順序付けを提供しなければならない。

### フロー制御

抽象的なトランスポートレベルではフロー制御はないが、アプリケーションはト ランスポートの一部としてフロー制御を自由に実装することができる。  例えば、TCPソケットが使用される場合、TCPの一部として自動的なフロー制御が存在する。

フロー制御は、バッファの過剰な確保を避けるために、メモリ量の非常に少ないデバイスでは必要かもしれない。

### 圧縮

非常に低速なリンクでは、アプリケーション固有のトランスポートがデバッグトラフィックのストリーム圧縮を使用することが適切である場合があります。  圧縮は、ストリームを非圧縮サイズの10〜30%程度に減らすことができる。

### セキュリティ

環境によっては、デバッグトランスポートはセキュリティ上重要である場合があります。  そのような場合、アプリケーションはデバッグトランスポートに認証と暗号化（例：トランスポートにSSL/TLSを使用）を使用する必要があります。

### パケットベースのトランスポートの上に実装する。

このトピックは別のセクションで扱います。

### 開発時間輸送拷問オプション

DUK_USE_DEBUGGER_TRANSPORT_TORTURE という設定オプションを使うと、Duktape はすべてのデバッグトランスポートの読み込み/書き込み操作を 1 バイト単位で行うようになり、あるサイズのチャンクの読み込み/書き込みに関する不正な仮定をキャッチするのに役立ちます。

## デバッグストリームフォーマット

### 概要

デバッグ・プロトコルは、Duktape内部とデバッグ・クライアントの間で交わされる会話です。  ユーザーコードはデバッグプロトコルの内容を意識することはなく、デバッグターゲットとデバッグクライアントの間でストリームのチャンクを運ぶためのデバッグトランスポートを提供するだけです。

デバッグプロトコルはシンプルな3つのライフサイクルを持っています。

* ストリームが接続され、バージョン識別（Duktapeによって送信される）を待機しています。
* ストリームが接続され、アクティブに使用されている状態。  デバッグ・メッセージは、それぞれの方向で自由に交換されます。
* ストリームは切断されます。  これは明示的なデタッチ要求（つまり ``duk_debugger_detach()`` への呼び出し、ユーザーのトランスポートコールバックによって示される読み込み/書き込みエラー、Duktapeによって検出されるメッセージ構文エラー、またはDuktapeヒープ破棄によって起こります。

プロトコルはリクエストパイプラインを使用する。つまり、各ピアは前のリ クエストに対する応答を待つことなく、複数のリクエストを送ることが許される。  これを促進するために、すべてのリクエストは対応する応答/エラーメッセージを持ち、リクエストは常に再順序付けされることなく処理される。  どちらのピアもパイプライン化されたリクエストを送る必要はなく、例えばデバッグクライアントが別のリクエストを送る前に応答を待つことは全く問題ありません。

### バージョン識別

デバッグ・トランスポートが装着されているとき、Duktapeはバージョン識別をUTF-8でエンコードされた:という形の行として書き込みます。

```xml
<protocolversion> <SP (0x20)> <additional text, no LF> <LF (0x0a)>
```

現在のプロトコルのバージョンは「2」であり、識別行は現在、次のような形になっています。

```xml
2 <DUK_VERSION> <DUK_GIT_DESCRIBE> <target string> <LF>
```

プロトコルバージョン番号の後に続くものはすべて情報提供のみです。
例::

```
2 20000 v2.0.0 duk command built from Duktape repo
```

デバッグプロトコルのバージョンは、ユーザーコードへの定義として利用可能です (``duktape.h`` で定義されます)::

```
DUK_DEBUG_PROTOCOL_VERSION
```

これは、ターゲットがそのデバッグ機能を宣伝できる場合などに有用である。

デバッグクライアントはその行を解析し、最初にプロトコルバージョンをチェックする必要があります。プロトコルバージョンがサポートされていない場合、デバッグ接続は閉じられるべきです。  デバッグクライアントは、常にターゲットに存在するプロトコルバージョンに適応します。  バージョン識別に対する確認応答はなく、デバッグクライアントからの対応するハンドシェイクメッセージもありません。

バージョン識別（ハンドシェイク）が完了すると、デバッグストリームは以下に説明する異なるフレーミングに切り替わります。  このフレーミングはプロトコルのバージョンに依存する可能性があり、そのためバージョン識別が最初に処理されなければなりません。

バージョン識別形式に関するいくつかの根拠。

* 1行のテキスト文字列は一般的なハンドシェイク手法であり、（TCPトランスポートを使用している場合）ターゲットにtelnet接続でき、デバッガーポートに接続したことを容易に確認できるという利点があります。  また、例えばDuktapeがオプションの機能をアドバタイズできるように、簡単に拡張することができます（それが必要になった場合）。
* バージョン識別は、ハンドシェイク形式を変更することなく、将来的にプロトコルのフレームを変更することを可能にします。  もしバージョン識別が以下に述べるような複雑なフレームを使用するならば、 バージョンの互換性をより難しくするでしょう。
* Duktapeは、ただやみくもにバージョン識別を送信し、応答を解析する必要がないので、例えば1バイトのバージョンを送信することと比較して、人間が読めるバージョン識別行を持つことにほとんどコストはかかりません。
* デバッグ・クライアントのためにバージョン識別を追加することは、Duktapeにとって不必要なパース状態を意味します。  Duktapeにデバッグ・クライアントのバージョンを認識させるメリットはほとんどない。

### Dvalue

バージョン識別ハンドシェイクの後、デバッグストリームはそれぞれの方向に送られる *dvalues* と呼ばれる型付き値で構成される。  Dvalues はメッセージフレームマーカー、整数、文字列、タグ付き ECMAScript 値などを表現する。  これらはコンテキストなしで解析することができ、ダンプに便利であり、またコンテキストなしで dvalues (とデバッグメッセージ) をスキップすることができる。  デバッグメッセージは、開始マーカ、0個以上のd値、メッセージ終了マーカからなる一連のd値として構築される。

次の表は、dvalueとそのフォーマットについてまとめたものである。  初期バイト(IB)は、タイプタグとして、また、値の一部を含むものとして使用される場合がある。


|           Byte sequence            |   Type    |                                                              Description                                                               |
| ---------------------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| 0x00                               | EOM       | メッセージの終わり                                                                                                                     |
| 0x01                               | REQ       | リクエストメッセージの開始                                                                                                             |
| 0x02                               | REP       | 成功返信メッセージの開始                                                                                                               |
| 0x03                               | ERR       | エラー返信メッセージの開始                                                                                                             |
| 0x04                               | NFY       | 通知メッセージの開始                                                                                                                   |
| 0x05...0x0f                        | reserved  |                                                                                                                                        |
| 0x10 `<int32>`                     | integer   | 4 バイト整数，符号付き 32 ビット整数，ネットワーク順で先頭バイトに続く。                                                               |
| 0x11 `<uint32>` `<data>`           | string    | 4 バイト文字列、符号なし 32 ビット文字列長でネットワーク順、文字列データは先頭バイトに続く。                                           |
| 0x12 `<uint16>` `<data>`           | string    | 2 バイト文字列、符号なし 16 ビット文字列長、ネットワーク順、文字列データは先頭バイトに続く。                                           |
| 0x13 `<uint32>` `<data>`           | buffer    | 4 バイトバッファ、符号なし 32 ビットバッファ長、ネットワーク順、バッファデータは先頭バイトに続く。                                     |
| 0x14 `<uint16>` `<data>`           | buffer    | 2 バイトバッファ、符号なし 16 ビットバッファ長、ネットワーク順、バッファデータは先頭バイトに続く                                       |
| 0x15                               | unused    | 内部的にはマッピングされていない配列エントリをマークするために使用され、デバッガプロトコルでは "none "の結果を示すために使用されます。 |
| 0x16                               | undefined | ECMAScript "undefined"                                                                                                                 |
| 0x17                               | null      | ECMAScript "null"                                                                                                                      |
| 0x18                               | true      | ECMAScript "true"                                                                                                                      |
| 0x19                               | false     | ECMAScript "false"                                                                                                                     |
| 0x1a `<8 bytes>`                   | number    | IEEEダブル（ネットワークエンディアン）                                                                                                 |
| 0x1b `<uint8>` `<uint8>` `<data>`  | object    | クラス番号、ポインタ長、ポインタデータ(ネットワークエンディアン)                                                                       |
| 0x1c `<uint8>` `<data>`            | pointer   | ポインタ長、ポインタデータ(ネットワークエンディアン)                                                                                   |
| 0x1d `<uint16>` `<uint8>` `<data>` | lightfunc | Lightfuncフラグ、ポインタ長、ポインタデータ(ネットワークエンディアン)                                                                  |
| 0x1e `<uint8>` `<data>`            | heapptr   | ポインタの長さ、ポインタデータ（ネットワークエンディアン）；ヒープオブジェクトへのポインタ、DumpHeapで使用される                       |
| 0x1f                               | reserved  |                                                                                                                                        |
| 0x20...0x5f                        | reserved  |                                                                                                                                        |
| 0x60...0x7f `<data>`               | string    | 長さ [0,31] の文字列、文字列の長さは IB - 0x60, データは以下の通り。                                                                   |
| 0x80...0xbf                        | integer   | 整数 [0,63]、整数値はIB - 0x80                                                                                                         |
| 0xc0...0xff `<uint8>`              | integer   | 整数 [0,16383], 整数値は ((IB - 0xc0) << 8) + followup_byte です。                                                                     |


すべての "integer "表現は意味的に同じであり，整数が期待されるところではすべて使用することができる。  文字列 "と "バッファ "表現も同様である。

dvalue の型付けは ``duk_tval`` の値を表現するのに十分であり、型付けを保持することができます (例えば、文字列とバッファは別々の型を持っています)。

dvalueは以下のテキストで以下のように表現される(テキスト中のすべての型に必要なわけではない)::

```
EOM
REQ
REP
ERR
NFY
<int: field name>      e.g. <int: error code>
<str: field name>      e.g. <str: error message>
<buf: field name>      e.g. <buf: buffer data>
<ptr: field name>      e.g. <ptr: prototype pointer>
<tval: field name>     e.g. <tval: eval result>
<obj: field name>      e.g. <obj: target>
<heapptr: field name>  e.g. <heapptr: target>
```

これらの追加的な表記は次の通りである。

```
# 1つの整数または2つの文字列のような代替。
(<int: foo> | <str: bar> <str: quux>)

# 繰り返し、例えば0-N個の整数。
[<int: foo>]*

# 繰り返し、例えば1-N個の値、各文字列または整数。
[<str: foo> | <int: bar>]+
```

フィールドが ECMAScript の値と正確に関連しない場合、例えばフィールドがデバッガ制御フィールドである場合、型付けは緩くなることがある。  例えば、boolean フィールドは integer dvalue として、任意のバイナリ文字列は string dvalue として表現されることがあります。  各コマンドで使用される具体的な型は、以下のコマンドごとのセクションで説明します。

dvalue形式の背後にある意図は、次のとおりです。

* 最下層のプロトコルを型付けし、解析される特定のメッセージを知ることなく、dvalueとメッセージをダンプできるようにする。
* EOMマーカーをスキャンすることで、メッセージの内容を理解せずに メッセージをスキップする、あるいはメッセージの末尾のフィールドを 無視する方法を提供する。これは、サポートされていないリクエストを処理したり、既存のものに dvalue を追加してメッセージを拡張したりするのに便利である。  しかし、信頼性のあるスキップは、実装がすべてのd値の型を解析し、その長さを知ることができる場合にのみ可能であることに注意してください。  特に、(EOMに使用される)ゼロバイトはdvalueの内部にも現れることが あるので、ゼロバイトにスキップすることは信頼できるスキップの方法 ではない。
* これは、両方のピアが、それ自身のリクエストに対するリプライと、相手から 開始されたリクエストまたは通知とを確実に区別できるようにするために必要であ る。
* 最終メッセージの長さを事前に知ることなく、デバッグメッセージのストリーム書き込みを許可する(これは、たとえばフレーミングが先行メッセージ長フィールドを持つ場合に必要である)。  これは、メッセージのサイズを事前に計算したり、送信前に完全なメッセージを 作成するために蓄積バッファを使用する必要性を回避するのに便利です。
* すべての ``duk_tval`` 値を情報を失うことなく表現します。
* 低帯域幅のデバッグ用トランスポート(シリアル回線など)のトラフィックを最小化するために、典型的な数値や文字列には短いエンコーディングフォームを使用します。
  - 整数の範囲 [0,63] は1バイトにエンコードされ、コマンド番号、ステータスコード、ブール値などに有効です。
  - 整数範囲 [0,16383] は2バイトにエンコードされ、例えば行番号、典型的な配列インデックス、ループカウンタ値などに有効です。
  - 長さ [0,31] の短い文字列は、1 バイトと文字列データにエンコードされます。  これは、典型的なファイル名、プロパティ名、変数名などに有効です。

注意事項

* ``duk_tval`` を送信しない場合、整数の値は常にプレーンな整数としてエンコードされなければなりません (IEEE double エンコーディングではありません)。
* duk_tval`` の値をパースする際には、プレーンな整数値と IEEE double 値の両方を受け入れなければなりません。  プレーンな整数は IEEE doubles に一意に対応するので、情報の損失はありません。  負の 0 は，符号を保持するために IEEE double として表現しなければならないことに注意してください．
* 高速整数(fastint)はデバッガープロトコルにおいて通常の数値と区別されません。
* バッファの値は明示的に表現されますが、バッファオブジェクト(Node.js Buffer, ArrayBuffer, DataView, TypedArray ビュー)はオブジェクトとして表現されます。  つまり、その内容は送信されず、ヒープポインタとクラス番号のみが送信されます。
* 未使用」値は特別です。Duktapeが内部的にマッピングされていない配列のエントリーをマークするために使用されますが、実際の値（値スタック上のエントリー、プロパティ値など）に使用されることは意図されていません。  unused" 値は、デバッガ・プロトコルで、いくつかのコマンド・リプライの欠落/無値を示すために使用されます。  リクエストでは使用されないので、デバッグ・クライアントはリクエスト（PutVarなど）で「unused」d値を送信してはいけません。

### エンディアン

原則として、すべての値はネットワークオーダー（ビッグエンディアン）にシリアライズされます。これはポインタ値やIEEEダブル値にも適用されます。

ポインタやIEEEダブルがバッファデータの一部である場合、それらはメモリ上に存在する任意の順序でエンコードされます。  これは、例えばDumpHeapによってダンプされたバイトコードは、プラットフォーム固有のバイトオーダーでバッファーの値として表現されることを意味します。  バイトオーダーを変更すると、デバッガーコードが特定のバッファ値のメモリレイアウトを認識する必要があるため、非常に厄介なことになります。

### duk_tvalの値を表現する

``duk_tval`` の値には、以下の dvalue タイプが使用される。

* 未使用（undefined/unused/none）：特定の dvalue。
* 未定義：特定の dvalue
* null: 固有の dvalue
* boolean: ``true`` と ``false`` に対応する特定の dvalue です。
* 数値：符号付き 32 ビット整数は，単純な整数の d 値で表現できる（負の 0 を除く），その他の数値はリテラルの IEEE 倍数として表現される．
* 文字列: いくつかの文字列長に対応する特定の d 値
* buffer: 数少ないバッファ長に対する特定のd値
* オブジェクト: ポインタとして表現される (デバッグクライアントからデバッグターゲットに送信される場合は危険)
* ポインター: ポインターとして表現
* lightfunc: ポイントとフラグフィールドで表現される（デバッグクライアントからデバッグター ゲットに送信される場合は危険）。

<tval: フィールド名>`` という記法では、 ``duk_tval`` と互換性のある任意の dval を使用することができます。  しかし、いくつかの値はデバッグクライアントからターゲットに送信する際に危険であることに注意してください。例えば、PutVar への引数として lightfunc 値を送信することは可能ですが、非常に注意しなければ簡単にセグメンテーションフォルトを起こすことができます。

### Request, replies, and notifications

リクエストは次のような形式です。

```
REQ <int: command> <0-N dvalues> EOM
```

成功応答は次のような形式です。

```
REP <0-N dvalues> EOM
```

エラー応答は、コマンドに依存しない **固定フォーマット** である。

```
ERR <int: error code> <str: error message or empty string> EOM
```

通知には、次のような形式があります。

```
NFY <int: command> <0-N dvalues> EOM
```

注意事項

* リクエストとリプライはメッセージIDを持たない: それは必要ない。  各ピアは、送られてくるリクエストに順番に応答することが要求される。また、 すべてのリクエストは、一つの成功またはエラー応答を持つことが要求されるので、 応答を以前に送ったリクエストに確実に関連付けることができる。  返信メッセージは、他の方向でピアから送られたリクエストや通知とまだ混 在しているかもしれない、ということに注意すること。
* 返信メッセージは、デバッグストリームでの順序に基づいて暗黙のうちに リクエスト/通知と関連付けられる。
* エラー応答は、エラー処理を統一するために決まった形式を持ちます。デバッグクライアントが新しいコマンドがサポートされているかどうかを簡単に チェックし、サポートされていなければ他のコマンドにフォールバックできるように、 「unsupported command」に対する特定のエラーコードを用意しています。
* Duktapeは現在、通知のみを送信し、リクエストは送信しません。

### Error codes

| Code |                            Description                             |
| ---- | ------------------------------------------------------------------ |
| 0x00 | 不明または未指定のエラー                                           |
| 0x01 | 非対応のコマンド                                                   |
| 0x02 | 多すぎる（例：ブレークポイントが多すぎる、新規に追加できないなど） |
| 0x03 | 見つかりません（例：無効なブレークポイントインデックス）           |
| 0x04 | アプリケーションエラー（例：AppRequest関連エラー）                 |

### インバウンドリクエストの対応

どちらかのピアが何か予期せぬことが起こったと判断した場合、単にトランスポートをドロップすることができます。  Duktapeがこれを検出するとすぐに、デバッガは自動的に切り離され、通常の実行が再開されます。  これは予期せぬエラーに対する統一されたハンドリングを提供し、例えば以下のような場合に適切な動作となります。

* 無効な、あるいは非常識なdvalueフォーマットに遭遇した場合。  このような場合、確実に実行を継続する方法がないことがよくあります。
* サポートされているコマンドが処理されているときにパースエラーが発生した。  このような状況は、ピアにバグがあるか、一貫性のない状態であることを示しています。

正確なエラー処理規則は、ここではあまり詳細に規定しませんが、重要な規則がいくつかあります。
拡張性のために重要なルールがいくつかある。

* ピアは、サポートされていないコマンド番号のリクエストを受信した場 合、そのコマンドがサポートされていることを示すエラー応答を返さなければ ならず[MUST NOT]、デバッグ接続を切断してはならない[MUST NOT]。  この動作は、ピアがコマンドを試してたまたまサポートされてい るかどうかを確認し、サポートされていない場合は他の動作にフォールバッ クできるようにするために、重要である。  その結果、常にプロトコルのバージョンを厳密に上げることなく新しいコマンドを追加することができ、オプションやカスタム、ターゲット固有のコマンドを追加して、それらを「調査」することが可能になります。
  - 今のところ、これはDuktapeにのみ適用されます。Duktapeはリクエストを送信せず、通知のみを送信します。
Duktapeはリクエストを送ることはなく、通知だけを送ります。 * サポートされていないコマンド番号の通知を相手が受け取った場合、その通知を無視 しなければならず、デバッグ接続を切断してはいけません(MUST NOT)。その理由はリクエストと同じである。
* サポートされているコマンドがパースされ、EOMの前に追加のdvalueが ある場合、最後のdvalueは無視されなければならない[MUST]。  これは、新しいコマンド番号を割り当てたり、プロトコルのバージョンを上げ たりすることなく、既存のコマンドを(場合によっては)拡張することができる ようにするものである。

これらの単純なルールは実装が簡単で、いくつかの一般的なケースでプロトコルを優雅に拡張することができます(もちろんすべてではありませんが)。

### d値およびデバッグメッセージのテキスト表示

**これは、このドキュメントとduk_debug.jsのダンプで使用される情報提供の慣習です**。

Duktapeデバッグクライアントは、以下の規約を使用して、dvalueをテキストで表現します。
Duktapeデバッグ・クライアントは、dvaluesをテキストとして表現するために、以下の規約を使用します。

* マーカバイト: ``EOM``, ``REQ``, ``REP``, ``ERR``, ``NFY``.
* 整数: ``-123`` などのように、文字列を正規化したもの。
* 文字列は、バイト列 (0x00...0xff) からコードポイント U+0000...U+00FF に1対1でマッピングされ、JSON にエンコードされる。  JSONエンコーディングは、結果にエスケープされていない改行がないことを保証します。  標準的なJSONは、コードポイントU+0080...U+00FFをすべてエスケープしないので、残念ながらおかしなことになります（ASCIIのみのシリアライズが望ましいでしょう）。
* その他の型は、JSONマッピングのようにJSONエンコードされています、以下を参照してください。

デバッグメッセージは、関連するすべてのd値(メッセージタイプマーカーとEOMを含む)を空白で区切った1行で表現されるだけです。これにより、テキストダンプは読みやすく、カットアンドペーストや診断などが容易になります。

例として、ペイロードが文字列「touché」、整数「123」、整数「-321」からなる応答を考えてみよう。  この文字列は、Duktape内部でUTF-8シーケンス:.Touchéとして表現されます。

```
74 6f 75 63 68 c3 a9
```

返信メッセージの生のバイトは、（パイプで区切られたdvaluesで）次のようになります：。

```
02 | 67 74 6f 75 63 68 c3 a9 | c0 7b | 10 ff ff fe bf | 00
```

これは、テキストのワンライナーとしてレンダリングされます：

```
REP "touch\u00c3\u00a9" 123 -321 EOM
```

Duktape内部で文字列が使用する正確なバイト数を維持するために、奇数文字列のマッピングが選択されます。  Duktapeの文字列の中には、意図的に無効なUTF-8を使用しているものがあるので、Unicodeにマッピングすることが常に選択肢になるわけではないことに注意してください。  この文字列マッピングは、バッファ・データを表現するためにも使用されます。

### デバッグ・プロトコルのためのJSONマッピング

このセクションで説明するマッピングは、デバッグのd値やメッセージをJSONの値にマッピングするために使用されます。  このマッピングは JSON デバッグプロキシーの実装に使用され、デバッグクライアントはバイナリプロトコルを全く実装せずに、クリーンな JSON メッセージだけを使用してデバッグターゲットと対話できるようになります。

### dvalues の JSON 表現

* Unused::

```json
{ "type": "unused" }
```

* Undefined::

```json
{ "type": "undefined" }
```

* Null、true、falseはJSONに直接マッピングされます。

```json
null
true
false
```

* 整数は、JSONの数値型に直接マッピングされます：。

```json
1234
```

* JSONの数値として損失なく表現できない数値（無限大、NaN、負のゼロなど）は、次のように表現されます。

```json
// data contains IEEE double in big endian hex encoded bytes
// (here Math.PI)
{ "type": "number", "data": "400921fb54442d18" }
```

このオブジェクトには、オプションで ``value`` フィールドを含めることができ、これは JSON 互換の近似値として数値を提供します。  このフィールドは、JSON互換の近似値として数値を提供します。生のIEEE doubleと比較して、いくつかの精度が失われる可能性があります。  また、NaNや無限大の場合は ``null`` となり、コードを書く際に ``JSON.stringify()`` で値をエンコードすることができるようになります。  例::

```json
// 4.5
{ "type": "number", "data": "4012000000000000", "value": 4.5 }

// +Infinity
{ "type": "number", "data": "7ff0000000000000", "value": null }
```

**重要**: ``value`` のキーは機械的に処理されてはならず、JSON プロトコルのテキストを直接読みやすくするためにのみ存在する。  パースするコードは常にこれを無視し、代わりに ``data`` を使用しなければならない。

* 文字列はテキスト表現と同様にマッピングされます。すなわち、バイト 0x00...0xff は Unicode コードポイント U+0000...U+00FF: にマッピングされます。

```json
// 4 バイトの文字列 0xde 0xad 0xbe 0xef
"\u00de\00ad\00be\00ef"
```

この表現は、バイト単位で正確であり、UTF-8以外の文字列を正しく表現し、かつほとんどの実用的な（ASCII）文字列に対して人間が読みやすいという理由で使用されています。

* バッファデータは、16進エンコードされた形でオブジェクトに包まれて表現されます：。

```json
{ "type": "buffer", "data": "deadbeef" }
```

* メッセージフレーミングの d 値 (EOM, REQ, REP, NFY, ERR) は、JSON プロトコルでは見えません。  これらは ``duk_debug.js`` が内部で次のようなフォーマットで使用しています::

```json
{ "type": "eom" }
{ "type": "req" }
{ "type": "rep" }
{ "type": "err" }
{ "type": "nfy" }
```

* Object::

```json
// classは数値，ポインタは16進数である．
{ "type": "object", "class": 10, "pointer": "deadbeef" }
```

* Pointer::

```json
// ポインタは16進数である
{ "type": "pointer", "pointer": "deadbeef" }
```

* Lightfunc::

```json
// flagsはJSONの数値として表現される16ビット整数、ポインタは16進数で表現されます。
{ "type": "lightfunc", "flags": 1234, "pointer": "deadbeef" }
```

* Heap pointer::

```json
// ポインタは16進数である
{ "type": "heapptr", "pointer": "deadbeef" }
```

### デバッグメッセージのJSON表現

メッセージは、以下のようにメッセージタイプマーカーとEOMマーカーを削除したJSONオブジェクトとして表現される。

request メッセージは、'request' キーと dvalue のリスト (EOM は省略) を含む 'args' 配列を用いてコマンドを指定します::

```json
{
    "request": "AddBreak",
    "args": [ "foo.js", 123 ]
}
```

args' 引数はオプションである。これがない場合は、空の配列と同じように扱われる: 。

```json
{
    "request": "AddBreak"
}
```

通常、デバッグコマンドは文字列として指定され、プロキシはデバッガのメタデータを使用して文字列をコマンド番号に自動的にマッピングします。  コマンド番号は明示的に指定することができ、さらに次のように両方指定することもできます。

```json
// 明示的なコマンド番号（例：メタデータがカスタムコマンドを知らない）。
{
    "request": 24,
    "args": [ "foo.js", 123 ]
}

// 同上、これは以前から使われていた形式です（上記の形式が望ましい）。
{
    "request": true,
    "command": 24,
    "args": [ "foo.js", 123 ]
}

// 'request' にはコマンド名を指定し、'command' には予備のコマンドを数値で指定することも可能です。  コマンド名がコマンドメタデータで解決できない場合は、'command' に指定したコマンド番号が使用されます (その場合のみ)。
{
    "request": "AddBreak",
    "command": 24,
    "args": [ "foo.js", 123 ]
}
```

返信メッセージはコマンド番号を持たないので、メッセージの種類を区別できるように、 「reply」キーに「true」をセットしておく。  引数は再び'args'（EOMは省略）になります。

```json
{
    "reply": true,
    "args": [ 3 ]
}
```

エラーメッセージは返信のようなもので、'error' キーには "true" 値が、'args' にはエラー引数（EOM は省略）が含まれます。

```json
{
    "error": true,
    "args": [ 2, "no space for breakpoint" ]
}
```

通知メッセージはリクエストと同じ形式ですが、「request」キーが「notify」に置き換えられています。

```json
{
    "notify": "Status",
    "args": [ 0, "foo.js", "frob", 123, 808 ]
}
```

通知コマンド番号の指定には、notifiesの代替形式も用意されています。

```json
{
    "notify": 1,
    "args": [ 0, "foo.js", "frob", 123, 808 ]
}

{
    "notify": true,
    "command": 1,
    "args": [ 0, "foo.js", "frob", 123, 808 ]
}

{
    "notify": "Status",
    "command": 1,
    "args": [ 0, "foo.js", "frob", 123, 808 ]
}
```

引数リストが空の場合、'args' はどのメッセージでも省略可能である。

要求メッセージと通知メッセージは、要求/通知コマンド名と番号の両方を含み、いくつかの形式がサポートされている。  コマンド名／番号は以下のように解決される。

* request' / 'notify' にコマンド名が文字列で指定されている場合、コマンドのメタデータ からコマンドを検索します。  コマンド名がわかっている場合、コマンドメタデータのコマンド番号を使用します (「command」キーの可能性は無視します)。
* request' / 'notify' でコマンド番号が指定されている場合は、その番号をそのまま使用します。
* command' がコマンド番号を提供している場合、それをそのまま使用します。  request' や 'notify' が ``true`` 値で存在する場合もありますが、無視されます。
* 上記の手順が失敗した場合、request/notifyは処理できません。

### その他のJSONメッセージ

上記のコアメッセージフォーマットに加えて、デバッグプロトコルのバージョン情報やトランスポートイベントのためのいくつかのカスタムメッセージがあります。  これらは、アンダースコアで始まる特別なコマンド名とコマンド番号のない「通知」メッセージとして表現されます。  これらは主に人間の読みやすさを向上させるためのもので、細かい部分は必要に応じて変更される可能性があります。

ターゲットへの接続が試みられると、次のようなnotifyが送信されます

```json
{
    "notify": "_TargetConnecting",
    "args": [ "1.2.3.4", 9091 ]
}
```

ターゲットに接続すると、バージョン識別がそのまま中継される。

```json
{
    "notify": "_TargetConnected",
    "args": [ "1 10199 v1.1.0-173-gecd806e-dirty duk command built from Duktape repo" ]
}
```

ターゲットが切断されたとき。

```json
{
    "notify": "_TargetDisconnected"
}
```

トランスポートエラーが発生した場合（ターミナルエラーとは限らないので、複数回表示される可能性がある）。

```json
{
    "notify": "_Error",
    "args": [ "some kind of error" ]
}
```

JSONプロキシ接続が切断される寸前の場合：。

```json
{
    "notify": "_Disconnecting"
}
```

オプションで reason 引数を含めることができる：。

```json
{
    "notify": "_Disconnecting",
    "args": [ "Target disconnected" ]
}
```

### JSONプロトコルのラインフォーマット

JSONメッセージは、コンパクトなワンライナー形式でエンコードされ、メッセージの最後に改行(LF文字1つ、0x0a)を入れて送信されます。(上記の例は、複数行のフォーマットで書かれていますが、これは **not** 許可されていないことに注意してください; これは単に分かりやすくするためです)。

この規約により、メッセージの読み書きが容易になります。  メッセージは簡単にカット・ペーストでき、メッセージ・ログを効果的にグ レープすることができます。

## プロトコルの拡張とバージョンの互換性

バージョン識別行は、デバッグプロトコルに互換性のない変更を加えるために使用されるプロトコルのバージョン番号を提供します; デバッグクライアントは常にターゲットのデバッグプロトコルバージョンに準拠するものと想定されます。

また、以下の基本的な方法で、プロトコルのバージョン番号を変更することなくプロトコルを拡張することが可能です。

* 新しいコマンドを追加する。  新しいコマンドを追加する。コマンドがサポートされていない場合、ピアは未知の/サポートされていないコマンドを示す特定のエラーを送り返す。

* リクエスト、レスポンス、または通知に末尾のフィールドを追加する。  ピアはサポートするフィールドを読み込んで処理した後、未知の末尾フィールドをスキップしてEOMに進むことが要求される。  メッセージの中には、可変数のフィールド(例えば、変数名/値ペアのリスト)を持つものがあり、その場合、このアプローチは不可能かもしれない。

これらの拡張は、(1) メッセージの内容を理解せずに EOM にスキップする機能、および (2) 未知のメッセージと未知の末尾 d 値に対する処理要件によって実現されています。

一般的な設計ルールとして、Duktape内部はバージョン特有の処理や回避策を排除しておく必要があります。  もし、ある機能が互換性のある方法できれいに実装できない場合、コマンドの並列変種を追加したり、他の厄介な妥協をしたりする代わりに、プロトコルのバージョンを上げる必要があります。デバッガのコードを小さくきれいに保ち、ターゲットでのコードフットプリントが損なわれないようにすることが重要です。

## Duktape が送るコマンド

### 状態通知(0x01)

フォーマット::

```xml
NFY <int: 1> <int: state> <str: filename> <str: funcname> <int: linenumber> <int: pc> EOM
```

例::

```
NFY 1 0 "foo.js" "frobValues" 101 679 EOM
```

何も実行していない時（例えば、Duktape の起動時以外から duk_debug_cooperate() が呼ばれた時） filename と funcname は未定義（d 値として "undefined" が使われる）、 pc/line は 0 になります。

状態は、以下のいずれかである。

* 0x00: 実行中
* 0x01: 一時停止中、デバッグクライアントを再開する必要があります。

実行状態が変化した場合（例：一時停止から実行中、またはその逆）、Duktapeは常にStatus通知を送信します。

デバッガを接続してDuktapeを実行している場合、どのファイル／行／関数が実行されているかをデバッグ・クライアントに知らせるために、随時ステータス通知を送信します。

ステータス更新のレートは、日付ベースのタイムスタンプを使用して自動的に制限されるため、Duktapeが通常モードまたはチェック・モードで動作している場合、ステータス更新は最大で200msごとに送信されます。

### 予約済み (0x02)

(Duktape 2.0.0で削除、Duktape 1.xで印刷通知）。

### 予約済み (0x03)

(Duktape2.0.0で削除。Duktape1.xではアラート通知)

### ログ通知(0x04)

(Duktape2.0.0で削除。Duktape1.xでログ通知)

### throw通知(0x05)

Format::

```xml
    NFY <int: 5> <int: fatal> <str: msg> <str: filename> <int: linenumber> EOM
```

Example::

```
    NFY 5 1 "ReferenceError: identifier not defined" "pig.js" 812 EOM
```

Fatalは、その一つです。

* 0x00: キャッチ
* 0x01: 致命的(捕捉されない)

Duktapeは、ランタイム・エラーによってDuktapeによって、あるいはECMAScriptコードによって直接、エラーが投げられるたびにThrow通知を送信します。

msgはスローされる文字列強制の値です。  ファイル名と行番号は、スローされたオブジェクトがErrorインスタンス（拡張後）であれば直接取得され、そうでなければ、これらの値はバイトコード・エグゼキュータの状態から計算されます。

### 通知解除 (0x06)

フォーマット：:

```xml
NFY <int: 6> <int: reason> [<str: msg>] EOM
```

例::

```
NFY 6 1 "d値のパースエラー" EOM
```

理由は以下のいずれかです。

* 0x00: 正常なデタッチ
* 0x01: ストリームエラーによるデタッチ

Duktapeは、デバッガがデタッチする際にDetaching通知を送信します。  クライアントがこの通知を見ることなくターゲットがトランスポートをドロップした場合、接続が失われたと仮定し、それに応じて対応することができます（例えば、リンクを再確立しようとする）。

msg`` はオプションの文字列で、切り離しの理由を詳しく説明します。  これは切り離しの性質によって、存在する場合としない場合があります。

### AppNotify notification (0x07)

フォーマット:

```
NFY <int: 0x07> [<tval>]* EOM
```

例:

```
NFY 7 "DebugPrint" "Everything is going according to plan!" EOM
```

これはカスタム通知メッセージで、その意味とセマンティクスはアプリケーションに依存します。
アプリケーションに依存します。

AppNotifyメッセージは、Duktapeデバッグ・プロトコルを介したデバッグ・クライアントとデバッグ・ターゲット間の直接通信のために使用されます。  カスタム・メッセージの意味とそれに含まれるdvalueの両方は、完全に実装次第であり、アプリケーションのニーズによっては、まったくサポートされないこともあります。

詳細については、以下の「カスタム・リクエストと通知」を参照してください。

## Commands sent by debug client

### BasicInfo request (0x10)

Format:

    REQ <int: 0x10> EOM
    REP <int: DUK_VERSION> <str: DUK_GIT_DESCRIBE> <str: target info>
        <int: endianness> <int: sizeof(void *)> EOM

Example:

    REQ 16 EOM
    REP 10099 "v1.0.0-254-g2459e88" "Arduino Yun" 2 4 EOM

Endianness:

-   1 = little endian
-   2 = mixed endian (doubles in ARM \"mixed\" endian, integers little
    endian)
-   3 = big endian

Endianness affects decoding of a few dvalues.

Target info is a string that can be compiled in, and can e.g. describe
the device type.

Void pointer size indicates pointer size used for pointer-related
values. Note that function pointers may have a different size.

### TriggerStatus request (0x11)

Format:

    REQ <int: 0x11> EOM
    REP EOM

Example:

    REQ 17 EOM
    REP EOM

Duktape will then re-send a status notify.

### Pause request (0x12)

Format:

    REQ <int: 0x12> EOM
    REP EOM

Example:

    REQ 18 EOM
    REP EOM

If Duktape is already paused, a no-op. If Duktape is running, Duktape
will check for incoming debug messages from time to time. When Duktape
notices the pause request (which can take seconds) it will reply to the
request, pause execution, and send a Status notification indicating it
has paused.

### Resume request (0x13)

Format:

    REQ <int: 0x13> EOM
    REP EOM

Example:

    REQ 19 EOM
    REP EOM

If Duktape is already running, a no-op. If Duktape is paused, it will
exit the debug message loop associated with the paused state (where
control is fully in the hands of the debug client), resume execution,
and send a Status notification indicating it is running.

### StepInto request (0x14)

Format:

    REQ <int: 0x14> EOM
    REP EOM

Example:

    REQ 20 EOM
    REP EOM

Resume execution and pause when execution exits the current line, enters
another function, exits the current function, or an error is thrown past
the current function (in which case execution pauses in the error
catcher, if any). If the current function doesn\'t have line information
(e.g. it is native), pauses on function entry/exit or error throw.

### StepOver request (0x15)

Format:

    REQ <int: 0x15> EOM
    REP EOM

Example:

    REQ 21 EOM
    REP EOM

Resume execution and pause when execution exits the current line, exits
the current function, or an error is thrown past the current function
(in which case execution pauses in the error catcher, if any). If the
current function doesn\'t have line information (e.g. it is native),
pauses on function exit or error throw.

### StepOut request (0x16)

Format:

    REQ <int: 0x16> EOM
    REP EOM

Example:

    REQ 22 EOM
    REP EOM

Resume execution and pause when execution exits the current function or
an error is thrown past the current function (in which case execution
pauses in the error catcher, if any).

### ListBreak request (0x17)

Format:

    REQ <int: 0x17> EOM
    REP [ <str: fileName> <int: line> ]* EOM

Example (two breakpoints):

    REQ 23 EOM
    REP "foo.js" 102 "bar.js" 99 EOM

### AddBreak request (0x18)

Format:

    REQ <int: 0x18> <str: fileName> <int: line> EOM
    REP <int: breakpoint index> EOM

Example:

    REQ 24 "foo.js" 109 EOM
    REP 3 EOM

If there\'s no space for more breakpoints, a \"too many\" error is sent:

    REQ 24 "foo.js" 109 EOM
    ERR 2 "no space for breakpoint" EOM

### DelBreak request (0x19)

Format:

    REQ <int: 0x19> <int: index> EOM
    REP EOM

Example:

    REQ 25 3 EOM
    REP EOM

If an invalid index is used, an error reply is sent.

### GetVar request (0x1a)

Format:

    REQ <int: 0x1a> <int: level> <str: varname> EOM
    REP <int: 0/1, found> <tval: value> EOM

Example:

    REQ 26 -1 "testVar" EOM
    REP 1 "myValue" EOM

Level specifies the callstack depth, where -1 is the topmost (current)
function, -2 is the calling function, etc. If not provided, the topmost
function will be used.

### PutVar request (0x1b)

Format:

    REQ <int: 0x1b> <int: level> <str: varname> <tval: value> EOM
    REP EOM

Example:

    REQ 27 -1 "testVar" "newValue" EOM
    REP EOM

Level specifies the callstack depth, where -1 is the topmost (current)
function, -2 is the calling function, etc. If not provided, the topmost
function will be used.

### GetCallStack request (0x1c)

Format:

    REQ <int: 0x1c> EOM
    REP [ <str: fileName> <str: funcName> <int: lineNumber> <int: pc> ]* EOM

Example:

    REQ 28 EOM
    REP "foo.js" "doStuff" 100 317 "bar.js" "doOtherStuff" 210 880 EOM

List callstack entries from top to bottom.

### GetLocals request (0x1d)

Format:

    REQ <int: 0x1d> <int: level> EOM
    REP [ <str: varName> <tval: varValue> ]* EOM

Example:

    REQ 29 -1 EOM
    REP "x" "1" "y" "3.1415" "foo" "bar" EOM

List local variable names from specified activation (the internal
`_Varmap`). Level specifies the callstack depth, where -1 is the topmost
(current) function, -2 is the calling function, etc.

The result includes only local variables declared with `var` and locally
declared functions. Variables outside the current function scope,
including outer functions and global variables, are not included.

::: note
::: title
Note
:::

The local variable list doesn\'t currently include dynamically declared
variables introduced by e.g. eval(), or variables with a dynamic scope
like the catch variable in try-catch. This will be fixed in future
versions.
:::

### Eval request (0x1e)

Format:

    REQ <int: 0x1e> (<int: level> | <null>) <str: expression> EOM
    REP <int: 0=success, 1=error> <tval: value> EOM

Example:

    REQ 30 null "1+2" EOM
    REP 0 3 EOM

Level specifies the callstack depth, where -1 is the topmost (current)
function, -2 is the calling function, etc. If not provided, the topmost
function will be used (as with a real `eval()`). The level affects only
the lexical scope of the code evaluated. The callstack will be intact,
and will be visible in e.g. stack traces and `Duktape.act()`. The level
can also be null to perform an indirect Eval.

If a valid callstack level is given, the eval expression is evaluated as
if a \"direct call\" to eval was executed in the position where
execution has paused, in the lexical scope specified by the provided
callstack level. A direct eval call shares the same lexical scope as the
function it is called from (an indirect eval call does not). For
instance, suppose we\'re executing:

    function foo(x, y) {
        print(x);  // (A)
        print(y);  // (B) <== paused here (before print(y))
    }

    foo(100, 200);

and you\'d eval:

    print(x + y); y = 10; "quux"

The Eval would execute as if the code had been:

    function foo(x, y) {
        print(x);
        eval('print(x + y); y = 10; "quux");
        print(y);
    }

    foo(100, 200);

so that the Eval statement would:

-   Print out 300 (using print).
-   Assign 10 to `y` so that statement B would then print 10 (instead of
    200).
-   The final result of the eval would be the string `"quux"`, which
    would then be shown in the debug client UI.

When Eval is requested from outside any Duktape activation, e.g. while
doing a duk_debugger_cooperate() call, there is no active ECMAScript
activation so that a \"direct\" Eval is not possible. Eval will then be
executed as an indirect Eval instead. As noted above, you can request an
indirect Eval explicitly by sending null for the callstack level.

Current limitations:

-   Can get stuck in an infinite loop.
-   The debug code runs inside an actual `eval()` call which affects the
    call stack. For example, `Duktape.act()` will see the additional
    stack frames.

### Detach request (0x1f)

Format:

    REQ <int: 0x1f> EOM
    REP EOM

Example:

    REQ 31 EOM
    REP EOM

Request that Duktape detach the debugger. Duktape requests the user
transport code to close the transport connection, and then resumes
normal execution.

### DumpHeap request (0x20)

Format:

    REQ <int: 0x20> EOM
    REP <dvalues> EOM

Example:

    REQ 32 EOM
    REP <dvalues> EOM

Dump contents of the entire Duktape heap. The format of the heap dump is
somewhat complicated; see `duk_debugger.c` for the format.

This is used to implement a debugger UI feature where you can download a
JSON dump of the heap state for analysis.

::: note
::: title
Note
:::

This command is somewhat incomplete at the moment. It will be useful to
implement a heap browser, and will probably be completed together with
some kind of UI.
:::

::: note
::: title
Note
:::

The dump format may potentially change to leverage GetHeapObjInfo to
read details of individual heap objects. This command would then simply
provide a list of objects the debug client can inspect on its own.
:::

### GetBytecode request (0x21)

Format:

    REQ <int: 0x21> (<int: level> | <obj: target> | <heapptr: target>) EOM
    REP <int: numconsts> (<tval: const>){numconsts}
        <int: numfuncs> (<tval: func>){numfuncs}
        <str: bytecode> EOM

Example without argument, gets bytecode for current function:

    REQ 33 EOM
    REP 2 "foo" "bar" 0  "...bytecode..." EOM

Callstack level can be given explicitly, for example -3 is the third
callstack level counting from callstack top:

    REQ 33 -3 EOM
    REP 2 "foo" "bar" 0  "...bytecode..." EOM

An explicit ECMAScript function object can also be given using an
\"object\" or \"heapptr\" dvalue:

    REQ 33 {"type":"object","class":6,"pointer":"00000000014839e0"} EOM
    REP 2 "foo" "bar" 0  "...bytecode..." EOM

An error reply is returned if:

-   The argument exists but has an invalid type or points to a target
    value which is not an ECMAScript function.
-   Callstack entry doesn\'t exist or isn\'t an ECMAScript activation.

Notes:

-   Bytecode endianness is target specific so the debug client needs to
    get target endianness and interpret the bytecode based on that.
-   Minor change from Duktape 1.4.0: when the callstack entry doesn\'t
    exist Duktape 1.5.x and above will return an error rather than an
    empty result.

::: note
::: title
Note
:::

This command is somewhat incomplete at the moment and may be modified
once the best way to do this in the debugger UI has been figured out.
:::

::: note
::: title
Note
:::

This command may be removed in favor of using GetHeapObjInfo to get the
same bytecode information.
:::

### AppRequest request (0x22)

Format:

    REQ <int: 0x22> [<tval>*] EOM
    REP [<tval>*] EOM

Example:

    REQ 34 "GameInfo" "GetTitle" EOM
    REP "Spectacles: Bruce's Story" EOM

If the target hasn\'t registered a request callback, Duktape responds:

    ERR 2 "AppRequest unsupported by target" EOM

The application request callback may also indicate an error, e.g.:

    ERR 4 "missing argument for SetFrameRate"

This is a custom request message whose meaning and semantics depend on
the application.

AppRequest messages are used for direct communication between the debug
client and debug target over the Duktape debug protocol. Both the
meaning of a custom message and the dvalues it contains are entirely up
to the implementation and depending on the needs of the application,
need not be supported at all.

See \"Custom requests and notifications\" below for more details.

### GetHeapObjInfo (0x23)

Format:

    REQ <int: 0x23> (<heapptr: target> | <object: target> | <pointer: target>) EOM
    REP [<int: flags> <str/int: key> [<tval: value> | <obj: getter> <obj: setter>]]* EOM

Example:

    REQ 35 { "type": "heapptr", "pointer": "deadbeef" } EOM
    REP 0 "class_name" "ArrayBuffer" ... EOM

Inspect a heap object using the provided heap pointer; any dvalue type
containing a pointer is allowed: heapptr, object, pointer. The debug
client is responsible for ensuring that the pointer is safe, i.e. that
the pointer is valid and the pointer target is still in the Duktape
heap:

-   When the debugger is paused garbage collection is automatically
    disabled so that any pointers obtained while the debugger remains
    paused are safe. Once execution is resumed using Resume or a step
    command, all pointers are potentially invalidated by garbage
    collection.
-   When the debugger is not paused the debug client may safely inspect
    an object if it\'s known with 100% certainty that the object is
    reachable and therefore safe to inspect. Because this is generally
    not a safe assumption, you should avoid making it unless it\'s
    really necessary.
-   **WARNING**: Inspecting an unsafe pointer causes memory unsafe
    behavior and may lead to crashes, etc.

The result is a list of artificial property entries, each containing a
flags field, a key, and a value. See GetObjPropDesc for the shared
format used.

Artificial properties are not actually present in a property table but
are generated based on e.g. `duk_heaphdr` flags and are string keyed to
make versioning easier. Artifical properties expose internal fields
which may change between versions and are not part of version
guarantees. As a result the artificial property keys and/or values may
change between versions. However, because the properties are string
keyed it\'s relatively easy for the debug client to adapt to such
changes.

The current artificial keys are described in the section \"Heap object
inspection\".

### GetObjPropDesc (0x24)

Format:

    REQ <int: 0x24> <obj: target> <str: key> EOM
    REP <int: flags> (<str: key> | <int: key>) (<tval: value> | <obj: getter> <obj: setter>) EOM

Example:

    REQ 36 { "type": "object", "class": 10, "pointer": "deadbeef" } "message" EOM
    REP 7 "message" "Hello there!" EOM

Inspect a property of an ECMAScript object using a specific string key
without causing side effects such as getter calls or Proxy traps. The
result is either:

-   A property value using the format described below.
-   A \"not found\" error if the property doesn\'t exist.

Properties stored in the internal \"array part\" are indexed using
numeric string keys, e.g. `"3"`, not integers.

Proxy objects are inspected as is without invoking any traps. The only
properties usually available are the Duktape specific internal control
properties indicating the target and the handler object with traps. A
Proxy object can be reliably detected using the artificial property
`exotic_proxyobj` returned by GetHeapObjInfo.

See GetHeapObjInfo for notes about pointer safety.

Each property entry is described using the following sequence of dvalues
(this format is shared with other property related commands, including
GetHeapObjInfo and GetObjPropDescRange):

-   Flags field
    -   A bit mask (described below)
-   Key
    -   Always a string, for array index properties convert index to
        canonical index string (e.g. `"3"`)
-   Property value:
    -   If property is not an accessor (apparent from flags field):
        single dvalue representing a duk_tval
    -   If property is an accessor: two dvalues pointing to getter and
        setter functions (respectively)

The flags field is an unsigned integer bitmask with the following bits:

  -----------------------------------------------------------------------
  Bitmask   Description
  --------- -------------------------------------------------------------
  0x01      Property attribute: writable, matches
            DUK_PROPDESC_FLAG_WRITABLE.

  0x02      Property attribute: enumerable, matches
            DUK_PROPDESC_FLAG_ENUMERABLE.

  0x04      Property attribute: configurable, matches
            DUK_PROPDESC_FLAG_CONFIGURABLE.

  0x08      Property attribute: accessor, matches
            DUK_PROPDESC_FLAG_ACCESSOR.

  0x10      Property is virtual, matches DUK_PROPDESC_FLAG_VIRTUAL.

  0x100     Property key is a Symbol.

  0x200     Property is a hidden Symbol which is not visible to ordinary
            ECMAScript code.
  -----------------------------------------------------------------------

For artificial properties (returned by GetHeapObjInfo) the property
attributes are not relevant (sent as zero) and the value is currently
never an accessor.

### GetObjPropDescRange (0x25)

Format:

    REQ <int: 0x25> <obj: target> <int: idx_start> <int: idx_end> EOM
    REP [<int: flags> (<str: key> | <int: key>) (<tval: value> | <obj: getter> <obj: setter>)]* EOM

Example:

    REQ 37 { "type": "object", "class": 10, "pointer": "deadbeef" } 0 2 EOM
    REP 7 "name" "Example object" 7 "message" "Hello there!" EOM

Inspect a range `[idx_start,idx_end[` of an ECMAScript object\'s \"own\"
properties. Result contains properties found; if the start/end index is
larger than available property count those values will be missing from
the result entirely. For example, if the object has 3 properties and the
range `[0,10[` is requested, the result will contain 3 properties only.
If the indices are crossed (e.g. `[10,5[`) an empty result is returned.

The indices in the range `[idx_start,idx_end[` refer to a conceptual
index space which is guaranteed to be stable as long as (1) execution is
paused so that garbage collection is prevented, and (2) the object is
not mutated. The property order within the index space has no specific
guarantees and does not necessarily match enumeration order; the debug
client should reorder the properties if a specific presentation order is
needed.

The current index space (which may change in future versions) contains:

-   The object\'s internal array part, indices `[0,a_size[`. Here
    `a_size` is the space allocated for the dense array part and may be
    larger than the apparent `.length` property of the array. Unmapped
    values and missing array indices are returned as \"unused\" dvalues.
-   The object\'s internal entry part, indices `[0,e_next[`. The entry
    part may contain deleted properties which are returned as \"unused\"
    dvalues.

The debug client doesn\'t need to care about these details, and can
simply read arbitrary ranges (even those spanning the two parts)
provided that it correctly deals with \"unused\" values.

The debug client can request all properties simply by requesting the
index range `[0,0x7fffffff[` (signed indices for now). The result will
only contain as many properties as are actually present.

The debug client can also iterate over the property set incrementally as
follows:

-   Request index ranges in sequence, for example `[0,10[`, `[10,20[`,
    etc.
-   When a partial result (here less than 10 properties) is received,
    we\'re done. Equivalent approach is to stop iterating when you get
    an entirely empty result.

The properties included in the index space are the target object\'s
\"own\" properties, without side effects:

-   Property attributes are provided in a flags field. Internal
    properties, currently implemented using keys starting with the 0xFF
    byte, are flagged explicitly so that the debug client doesn\'t need
    to check the marker byte (which may change in future versions)
    separately.
-   Accessor properties are described as is, as a setter/getter pair,
    without invoking the getter. The debug client can do that explicitly
    if it so desires.
-   Inherited properties are not enumerated. The debug client can walk
    the prototype chain manually by looking up the `prototype`
    artificial property and inspecting that object separately. Prototype
    walking should carefully avoid failing on a prototype loop.
-   Some properties which are implemented in a fully virtualized fashion
    are visible in ECMAScript enumeration but may not be visible in the
    inspection. For example, String object has virtual index properties
    (0, 1, 2, \...) for string characters, and these are not included in
    the inspection result at the moment. They can be read using
    GetObjPropDesc, however.
-   Proxy traps are not invoked, and the properties returned are the
    \"own\" properties of the Proxy itself. Typically the Proxy has only
    Duktape specific internal control properties identifying the Proxy
    target and handler table.

Note that Array objects can be dense or sparse. This distinction is
internal: dense arrays have an array part where the array items are
stored while sparse arrays don\'t have an array part and array items are
stored in the main property table together with normal string keyed
properties. Array items for sparse arrays will thus appear as normal
string keyed properties, and may not be in ascending index order; the
debug client should always reorder properties to fit the preferred
display order. Array gaps may be visible either as missing keys or as
keys with the dvalue \"unused\". Currently gaps in sparse arrays will be
visible as missing keys while gaps in dense arrays are visible as
\"unused\" dvalues; the debug client should handle both cases.

See GetHeapObjInfo for notes about pointer safety.

## Custom requests and notifications

Starting in Duktape 1.5.x, Duktape supports direct communication between
the debug client and debug target over the same transport by using the
special AppRequest and AppNotify messages. These messages have no
meaning to Duktape, which merely serves to marshal them back and forth
through a defined API.

AppNotify messages may be sent by pushing the contents of the message to
the stack and calling `duk_debugger_notify()` passing the number of
values pushed. Each value pushed will be sent as a dvalue in the
message. So if you push two strings, \"foo\" and \"bar\", the client
will see `NFY 7 "foo" "bar" EOM`.

AppRequest is used to make requests to the target which are not directly
related to ECMAScript execution and may be implementation-dependent. For
example, an AppRequest might be used to:

-   Download source files directly from the debug target file system
-   Change the frame rate of a game engine
-   Reset/reboot an embedded target device while debugging
-   Perform or trigger software or script updates

A target that wishes to support AppRequest should provide a request
callback when calling `duk_debugger_attach()`. When an AppRequest is
received, the request callback is invoked with the contents of the
message on the value stack, and may push its own values to be sent in
reply. The request callback may block if necessary (for example, the
callback might wait for a hardware button press). Note, however, that
Duktape will also be blocked while the callback executes which may not
be desirable in some cases and may cause a debug client to time out
(this of course depends entirely on the debug client).

This is a minimal do-nothing request callback:

    duk_idx_t duk_cb_debug_request(duk_context *ctx, void *udata, duk_idx_t nvalues) {
        /* Number of return values is returned: here empty reply. */
        return 0;
    }

The above dummy callback simply responds with `REP EOM` (an empty reply)
to all requests.

A more useful callback should process the values it receives on the
value stack, push its own values to send in reply, and return a
non-negative integer indicating how many values it pushed. Here is a
slightly more useful implementation:

    duk_idx_t duk_cb_debug_request(duk_context *ctx, void *udata, duk_idx_t nvalues) {
        const char *cmd_name = NULL;

        /* Callback must be very careful NEVER to access values below
         * 'nvalues' topmost value stack elements.
         */
        if (nvalues >= 1) {
            /* Must access values relative to stack top. */
            cmd_name = duk_get_string(ctx, -nvalues + 0);
        }

        if (cmd_name == NULL) {
            /* Return -1 to send an ERR reply.  The value on top of the stack
             * should be a string which will be used for the error text sent
             * to the debug client.
             */
            duk_push_string(ctx, "missing application specific command name");
            return -1;
        } else if (strcmp(cmd_name, "VersionInfo") == 0) {
            /* Return a positive integer to send a REP containing values pushed
             * to the stack.  The return value indicates how many dvalues you
             * are including in the response.
             */
            duk_push_string(ctx, "My Awesome Program");
            duk_push_int(ctx, 81200);  /* ver. 8.12.0 */
            return 2;  /* 2 dvalues */
        } else {
            duk_push_sprintf(ctx, "unrecognized application specific command name: %s",
                             cmd_name);
            return -1;
        }
    }

If no request callback is provided at attach, AppRequest will be treated
as an unsupported command, eliciting an ERR reply from Duktape saying
so. A target is always free to send AppNotify messages.

As a precaution, the target should try to avoid sending structured
values such as JS objects in notify messages as their heap pointers may
become stale by the time the client receives and inspects them. This is
especially true for notifications sent while the target is running.
It\'s better to stick to primitives which have unique dvalue
representations, e.g. numbers, booleans, and strings. If a structured
value does need to be sent, it can simply be e.g. JSON/JX encoded and
sent as a string instead (carefully avoiding uncaught errors).

### Important notes on the request callback

The request callback is provided with a `duk_context` pointer with which
it can access the value stack and is assumed to be trusted. There are
certain things it MUST NOT do. Specifically:

-   It MUST NOT assume that `nvalues` has any specific value. In
    particular it might be zero so that there are no arguments to the
    callback (not even a string used, by convention, to identify an
    application specific command).
-   It MUST NOT attempt to access or pop any values from the top of the
    stack beyond the `nvalues` it is given and the values it pushes
    itself.
-   It MUST NOT assume any specific value for `duk_get_top()` and
    similar primitives. In practice this means using negative stack
    indices to access values.
-   It MUST NOT throw errors. It is very easy to accidentally throw an
    error when working with value stack values directly, so caution must
    be exercised here.

Violating this contract is undefined behavior and may corrupt debugger
state, cause incorrect behavior, or even lead to a segfault. In the
future it would be nice to make this more robust, e.g. by sandboxing the
function so that it cannot access unrelated stack values and is allowed
to throw errors safely.

The dvalues of a message are pushed in the order they are received. This
makes them inconvenient to access using negative indices, since the
relative position of any given value on the stack is dependent on the
total number of values. However because the callback receives the total
number of values as a parameter, a useful convention is to index the
stack like so:

    if (nvalues < 3) {
        duk_push_string(ctx, "not enough arguments");
        return -1;
    }
    cmd_name = duk_get_string(ctx, -nvalues + 0);
    val_1 = duk_get_string(ctx, -nvalues + 1);
    val_2 = duk_get_int(ctx, -nvalues + 2);

### AppRequest/AppNotify command format

As a general convention, it is recommended for the first field in an
AppRequest or AppNotify message after the command number be a string
identifying the command, e.g. \"VersionInfo\" or \"RebootDevice\". This
makes it simpler for different clients and targets to interoperate.
Unrecognized command names can simply be ignored, whereas, e.g. integer
commands may be interpreted differently depending on the debug client
and target in use.

If a command is specific to your application in some way (purpose or
behavior), it might make sense to add a prefix, e.g.
\"MyApp-AwesomeCmd\". This avoids clashes with other targets which may
have similarly-named commands.

Ultimately, no convention or overall form for application message
contents is actually enforced by Duktape. A peer should therefore not
make any assumptions about the contents of an AppRequest or AppNotify
message unless it knows exactly where that message came from.

## Heap object inspection

Artificial keys are subject to change between versions.

The following, however, have versioning guarantees:

-   `prototype`: internal prototype (not to be confused with a possible
    \"prototype\" property, which is the external prototype).
-   `class_name`: string name for object class
-   `class_number`: object class number, matches object dvalue

### Duktape 1.5.0

The following list describes artificial keys included in Duktape 1.5.0,
see `src-input/duk_debugger.c` for up-to-date behavior:

  ----------------------------------------------------------------------------
  Artificial property    Object type(s)    Description
  key                                      
  ---------------------- ----------------- -----------------------------------
  `heaphdr_flags`        `duk_heaphdr`     Raw `duk_heaphdr` flags field; the
                         (all)             individual flags are also provided
                                           as separate artificial properties.

  `heaphdr_type`         `duk_heaphdr`     `duk_heaphdr` type field,
                         (all)             [\`DUK_HTYPE_xxx]{.title-ref}.

  `refcount`             `duk_heaphdr`     Reference count, omitted if no
                         (all)             refcount support.

  `extensible`           `duk_hobject`     DUK_HOBJECT_FLAG_EXTENSIBLE

  `constructable`        `duk_hobject`     DUK_HOBJECT_FLAG_CONSTRUCTABLE

  `callable`             `duk_hobject`     DUK_HOBJECT_FLAG_CALLABLE

  `bound`                `duk_hobject`     DUK_HOBJECT_FLAG_BOUND

  `compfunc`             `duk_hobject`     DUK_HOBJECT_FLAG_COMPFUNC

  `natfunc`              `duk_hobject`     DUK_HOBJECT_FLAG_NATFUNC

  `bufobj`               `duk_hobject`     DUK_HOBJECT_FLAG_BUFOBJ

  `fastrefs`             `duk_hobject`     DUK_HOBJECT_FLAG_FASTREFS

  `array_part`           `duk_hobject`     DUK_HOBJECT_FLAG_ARRAY_PART

  `strict`               `duk_hobject`     DUK_HOBJECT_FLAG_STRICT

  `notail`               `duk_hobject`     DUK_HOBJECT_FLAG_NOTAIL

  `newenv`               `duk_hobject`     DUK_HOBJECT_FLAG_NEWENV

  `namebinding`          `duk_hobject`     DUK_HOBJECT_FLAG_NAMEBINDING

  `createargs`           `duk_hobject`     DUK_HOBJECT_FLAG_CREATEARGS

  `have_finalizer`       `duk_hobject`     DUK_HOBJECT_FLAG_HAVE_FINALIZER

  `exotic_array`         `duk_hobject`     DUK_HOBJECT_FLAG_EXOTIC_ARRAY

  `exotic_stringobj`     `duk_hobject`     DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ

  `exotic_arguments`     `duk_hobject`     DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS

  `exotic_proxyobj`      `duk_hobject`     DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ

  `special_call`         `duk_hobject`     DUK_HOBJECT_FLAG_SPECIAL_CALL

  `class_number`         `duk_hobject`     Duktape internal class number (same
                                           as object dvalue).

  `class_name`           `duk_hobject`     String class name, e.g.
                                           `"ArrayBuffer"`.

  `prototype`            `duk_hobject`     Points to the effective (internal)
                                           prototype and allows enumeration of
                                           inherited properties in client
                                           control.

  `props`                `duk_hobject`     Current property table allocation.

  `e_size`               `duk_hobject`     Entry part size.

  `e_next`               `duk_hobject`     Entry part next index (= used
                                           size).

  `a_size`               `duk_hobject`     Array part size.

  `h_size`               `duk_hobject`     Hash part size.

  `length`               `duk_harray`      Array .length.

  `length_nonwritable`   `duk_harray`      Array .length writable (false) or
                                           non-writable (true).

  `thread`               `duk_hdecenv`     Thread for open declarative
                                           environment.

  `varmap`               `duk_hdecenv`     Varmap for open declarative
                                           environment.

  `regbase`              `duk_hdecenv`     Regbase for open declarative
                                           environment.

  `target`               `duk_hobjenv`     Target object for object
                                           environment.

  `has_this`             `duk_hobjenv`     True if object environment provides
                                           a \'this\' binding.

  (not present yet)      `duk_hnatfunc`    Native function pointer.

  `nargs`                `duk_hnatfunc`    Number of stack arguments.

  `magic`                `duk_hnatfunc`    Magic value.

  `varargs`              `duk_hnatfunc`    True if function has variable
                                           arguments.

  (not present yet)      `duk_hcompfunc`   ECMAScript function data area,
                                           including bytecode.

  `lex_env`              `duk_hcompfunc`   Function lexical environment.

  `var_env`              `duk_hcompfunc`   Function variable environment.

  `nregs`                `duk_hcompfunc`   Number of bytecode executor
                                           registers.

  `nargs`                `duk_hcompfunc`   Number of stack arguments.

  `start_line`           `duk_hcompfunc`   First source code line.

  `end_line`             `duk_hcompfunc`   Last source code line.

  (no properties yet)    `duk_hthread`     No thread properties yet.

  `buffer`               `duk_hbufobj`     Underlying plain buffer (provided
                                           as a heapptr).

  `slice_offset`         `duk_hbufobj`     Byte offset to underlying buffer
                                           for start of slice.

  `slice_length`         `duk_hbufobj`     Byte length of slice.

  `elem_shift`           `duk_hbufobj`     Shift value for element, e.g.
                                           Uint64 -\> 3.

  `elem_type`            `duk_hbufobj`     DUK_HBUFOBJ_ELEM_xxx

  `is_typedarray`        `duk_hbufobj`     True if bufferobject is a typed
                                           array (e.g. Uint8Array).

  `extdata`              `duk_hstring`     DUK_HSTRING_FLAG_EXTDATA

  `bytelen`              `duk_hstring`     Byte length of string.

  `charlen`              `duk_hstring`     Character length of string.

  `hash`                 `duk_hstring`     String hash, algorithm depends on
                                           config options.

  `data`                 `duk_hstring`     Plain string value.

  `dynamic`              `duk_hbuffer`     DUK_HBUFFER_FLAG_DYNAMIC

  `external`             `duk_hbuffer`     DUK_HBUFFER_FLAG_EXTERNAL

  `size`                 `duk_hbuffer`     Byte size of buffer.

  `dataptr`              `duk_hbuffer`     Raw pointer to current data area.

  `data`                 `duk_hbuffer`     Buffer data.
  ----------------------------------------------------------------------------

### Currently disabled

These are disabled (`if #0`\'d out) in code, and may be added back if
useful:

  ---------------------------------------------------------------------------------
  Artificial property key  Object type(s)   Description
  ------------------------ ---------------- ---------------------------------------
  `reachable`              `duk_heaphdr`    DUK_HEAPHDR_FLAG_REACHABLE
                           (all)            

  `temproot`               `duk_heaphdr`    DUK_HEAPHDR_FLAG_TEMPROOT
                           (all)            

  `finalizable`            `duk_heaphdr`    DUK_HEAPHDR_FLAG_FINALIZABLE
                           (all)            

  `finalized`              `duk_heaphdr`    DUK_HEAPHDR_FLAG_FINALIZED
                           (all)            

  `readonly`               `duk_heaphdr`    DUK_HEAPHDR_FLAG_READONLY
                           (all)            

  `arridx`                 `duk_hstring`    DUK_HSTRING_FLAG_ARRIDX

  `symbol`                 `duk_hstring`    DUK_HSTRING_FLAG_SYMBOL
                                            (DUK_HSTRING_FLAG_INTERNAL in Duktape
                                            1.x)

  `hidden`                 `duk_hstring`    DUK_HSTRING_FLAG_HIDDEN

  `reserved_word`          `duk_hstring`    DUK_HSTRING_FLAG_RESERVED_WORD

  `strict_reserved_word`   `duk_hstring`    DUK_HSTRING_FLAG_STRICT_RESERVED_WORD

  `eval_or_arguments`      `duk_hstring`    DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS
  ---------------------------------------------------------------------------------

## \"debugger\" statement

ECMAScript has a debugger statement:

    a = 123;
    debugger;
    a = 234;

The E5 specification states that:

> Evaluating the DebuggerStatement production may allow an
> implementation to cause a breakpoint when run under a debugger. If a
> debugger is not present or active this statement has no observable
> effect.

Other ECMAScript engines typically treat a debugger statement as a
breakpoint:

-   <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger>
-   <http://msdn.microsoft.com/en-us/library/ie/0bwt76sk%28v=vs.94%29.aspx>
-   <http://blog.katworksgames.com/2012/09/27/debugger-statement-makes-javascript-development-easier/>

Duktape interprets it as a breakpoint too, i.e. execution is paused if a
debugger statement is encountered while a debug client is attached. This
allows breakpoints to be set even in anonymous eval code (though there
will be no access to source code).

## Implementing a debug transport on top of a packet-based transport

Implementing a debug transport over a packet-based lower level protocol
is essentially the same problem as forwarding a TCP stream or a virtual
serial link over the packed-based protocol. There is very little Duktape
specific in doing so, and the problem is quite well understood. This
section provides some pointers.

### Basic issues

-   You\'ll need a mechanism to reliably send and receive arbitrary
    chunks of data with no reordering or duplication. This mechanism is
    needed both for the target and the debug client.
-   If buffering is an issue you may need to implement a flow control
    mechanism. Usually buffering is only an issue on the debug target,
    so one way flow control is usually enough.
-   To ensure data chunks sent by the debug target are reasonably sized,
    you may need to coalesce debug transport writes made by Duktape and
    use \"write flush\" to flush out pending bytes when no more data
    will be sent. Alternatively you could use a timer, similarly to what
    TCP does.

If you also implement your own debug client you need to parse the debug
stream from the data chunks received, e.g. with trial parsing:

-   Read an incoming data chunk and append it to an input byte buffer.
-   Trial parse for debug messages until no more complete messages can
    be parsed. Then wait for next inbound data chunk.
-   **Because the boundaries of debug messages are not guaranteed to
    align with the read/write calls Duktape makes into the transport
    implementation, you should not try to match debug messages to the
    data chunks sent/received by your transport implementation!**

### Coalescing writes example

-   Maintain a buffer BUF of max N bytes for outbound writes.
-   For each Duktape transport write call:
    -   If the write data fits into BUF, append it. If not, append as
        many bytes as fit in the remaining BUF space (partial write).
    -   If the buffer is now full (N bytes), send and empty the buffer.
    -   Return value to Duktape indicates how many values were consumed,
        i.e. appended to BUF.
-   For each Duktape transport write flush:
    -   If there are bytes in BUF, send and empty the buffer.
    -   Note that you can rely on Duktape performing a write flush
        before it finishes writing and e.g. blocks on read or resumes
        execution. Write flushes may also happen at other times.
        **Don\'t assign any other meaning to the flushes, e.g. a write
        flush is not guaranteed to match debug message boundaries!**

### One-way flow control example

A simple one-way flow control mechanism to ensure a debug target can be
implemented with a fixed inbound buffer of MAXBUF bytes (MAXBUF is
something small like 256):

-   The debug client maintains two byte counts:
    1.  SENT indicates how many bytes have been sent since the start of
        the debug connection.
    2.  ACKED indicates how many bytes the debug target has confirmed to
        have consumed. SENT - ACKED is the number of bytes potentially
        in the target input buffer.
-   The debug client then knows that the target can buffer at least
    MAXBUF - (SENT - ACKED) bytes, so that it\'s free to send that
    amount.
-   When the debug target receives data chunks from the debug client,
    it:
    -   Appends the data chunk to an inbound data buffer. There should
        always be space for the data if the debug client behaves
        correctly.
-   When Duktape calls the debug transport read callback:
    -   Consume bytes from the inbound data buffer.
    -   Send a transport specific notification to the debug client,
        updating the ACKED byte count (= number of bytes consumed by
        Duktape read calls).

Because Duktape performs a lot of small reads, it may be useful to:

-   In the debug transport read callback:
    -   Don\'t send a notification for the updated ACKED byte count
        unless the change to a previously sent value is large enough.
-   Rely on the debug transport \"read flush\" indication:
    -   When received, always send a notification for the updated ACKED
        byte count.

There are many other options too, for example, send an updated ACKED
byte count when:

-   Receiving bytes from the debug target.
-   When Duktape reads bytes, only send an updated ACKED byte count when
    the read is made from a completely full input buffer (i.e., the
    debug client is currently not sending any data until we notify it we
    have space).

## Implementation notes

### Overview

This section contains some implementation notes on the Duktape
internals.

Duktape debugger support is optional and enabled with a config option.
The bytecode executor interrupt feature is also mandatory when debugger
support is enabled.

### Source files

The debugger support is implemented almost entirely in the following
files:

-   `duk_js_executor.c`: checked execution, breakpoints, step into/over,
    interfacing with debugger message loop
-   `duk_hthread_stacks.c`: step out handling
-   `duk_debugger.c`: debug transport, debug command handling
-   `duk_api_debug.c`: debugger API entrypoints

### Attaching and detaching a debugger to a heap

When user code attaches a debugger using `duk_debugger_attach()`,
Duktape updates the `duk_heap` state to reflect that a debugger is
attached, store the callbacks etc.

The debugger operates on a Duktape heap level, as other options seem to
lead to confusing outcomes. For instance, if a debugger were attached to
a single thread breakpoints would only be triggered by that thread. Even
so, when a breakpoint was triggered, the whole heap would be paused
because there\'s no way to pause a single thread and resume execution of
others.

### Execution modes, executor interrupt, and \"restart_execution\"

Perhaps the most critical capability needed to implement a debugger is
to have an efficient way of detecting active breakpoints, trigger on a
breakpoint, and implement stepped execution. These are implemented in
the Duktape bytecode executor as follows.

Debugger support relies on the executor interrupt feature, which
provides the ability to interrupt bytecode execution periodically or
after every bytecode instruction. This mechanism is used to implement
three conceptual modes of execution:

-   **Normal**: bytecode executor executes at full speed, calling into
    the executor interrupt once in a while. When in the interrupt, we
    peek for debug client messages (this allows an out-of-the-blue pause
    for instance), execution timeout etc.
-   **Checked**: bytecode executor executes opcodes one at a time,
    calling into the executor interrupt before every instruction. The
    interrupt detects line transitions, checks if any breakpoints or
    stepping related conditions are triggered, and peeks (but doesn\'t
    block waiting) for debug client messages.
-   **Paused**: bytecode executor calls into executor interrupt, and the
    executor interrupt processes debug client messages until the debug
    client issues some control flow related command like step
    over/into/out or resume. Execution is under complete control of the
    debug client.

The \"paused\" mode is concretely implemented in the executor interrupt
simply by processing debug messages until some kind of resume/detach
command is encountered.

The \"checked\" mode is implemented by careful management of the
interrupt counter. This is important so that no additional checks are
introduced into the executor fast path: only a single interrupt counter
check is needed. When execution is restarted, the need for checked
execution is detected (e.g. there are active breakpoints or stepping is
active) and the interrupt counter is configured to trigger an interrupt
before any opcodes are executed. If we need to remain in checked mode,
the interrupt handler will again configure the interrupt counter to
ensure only one opcode is executed before again returning to the
interrupt handler.

The \"normal\" execution mode is similar but the interrupt counter is
configured into a higher value (e.g. interrupt every hundred thousand
opcodes) when returning to the bytecode executor.

The `restart_execution:` label in the bytecode executor is an important
control point. It is called whenever the bytecode executor is about to
start executing a new activation, but can also be called explicitly e.g.
when debug commands have adjusted breakpoint state. The \"restart
execution\" operation does a lot of important things:

-   It checks for debugger attached/detached state. If detached, all
    other debugger related checks are skipped.
-   It checks for active breakpoints in the current function, and writes
    out the active breakpoint list to make breakpoint trigger checks
    faster in the executor interrupt.
-   It checks for active stepping state. Both step into and step over
    require some handling.
-   It checks for paused state too. In some cases a \"paused\" flag can
    be set outside the bytecode executor. For example, when doing a
    \"step out\", the callstack unwinding code sets a \"paused\" flag
    when unwinding the activation we\'re stepping out of. We detect this
    only when \"restart execution\" is called the next time.
-   Ultimately, it decides whether execution should proceed in checked
    mode or normal mode.

After execution proceeds normally, with the help of the executor
interrupt mechanism and the interrupt handler. The execution mode can
only changed by the interrupt handler (e.g. if it starts setting the
interrupt counter to a higher value) or if \"restart_execution\" is
invoked again.

From the bytecode executor perspective the integration is quite simple:

-   \"restart_execution\" does a lot of debugger processing as part of
    setting up execution.
-   The interrupt counter mechanism is used to call into the interrupt
    handler, and the actual opcode executor doesn\'t have to worry about
    the rest.

### Stepping and pausing

The following internal heap level state is needed:

-   Pause state: heap wide flag indicating we need to talk with the
    debug client until it gives us as a permission to continue.
-   Step state: heap wide, tracks currently active \"step into\", \"step
    over\", or \"step out\" state.

The step state is rather tricky:

-   Step over: track the original thread, activation index, and starting
    line. Execute in checked mode until starting line has changed; then
    pause. If we call into other functions, the state is kept and we\'ll
    pause once we return and the line number has changed.

-   Step into: track the original thread, activation index, and starting
    line. Execute in checked mode until starting line has changed. If we
    call into another function, we need to pause when entering it.

-   Step out: track the original thread and activation index (starting
    line does not matter). Execute in normal mode (unless there are
    breakpoints, of course). If the activation is unwound for any
    reason, enter paused mode. This means that if an error is thrown, we
    resume execution in the catcher. Step out handling is concretely
    implemented as part of callstack unwinding, which differs completely
    from how other step commands are implemented.

    A coroutine yield does not trigger a \"step out\" because the
    callstack is not unwound.

Step over/into state is checked in executor \"restart execution\"
operation.

### Breakpoints

Breakpoints are maintained as a heap level file/line list. When the
bytecode executor does a \"restart execution\" operation it rechecks the
breakpoint list and figures out which breakpoints are active; the active
breakpoint list is recorded into the heap state too. Whenever breakpoint
state may have changed, e.g. as a result of executing debug commands,
the bytecode executor must go through a \"restart execution\" operation
so that breakpoints are properly re-checked and activated.

If there are one or more active breakpoints, execution resumes in
checked mode. If no breakpoints are active (and there\'s no other reason
to be in checked mode) execution resumes in normal mode. This is
important to maximize execution performance when breakpoints are active
but outside the currently executing function.

One key problem in figuring out the active breakpoints is how to handle
inner functions. This is covered in a separate section below.

Breakpoints are handled directly by Duktape to make them reasonably
efficient. Another design alternative would be to have an API or a
protocol mechanism for stepped execution so that user code could
implement breakpoints on its own. This would be more flexible than an
integrated breakpoint mechanism, but also much slower.

There are many design alternatives to defining a breakpoint using a
file/line pair. The current file/line approach is intuitive but means
that:

-   There\'s no way to break in the middle of a single line, e.g. for
    one-line functions. This also affects minified ECMAScript code.
-   There are potentially multiple ECMAScript function instance (i.e.
    `duk_hcompfunc` objects) that have been created from the same spot.
    The breakpoint will match all of them.

### Line transitions

It might seem at first that a line-to-PC conversion primitive would be
needed so that a line number could be translated into a PC for an active
breakpoint. However, such an approach doesn\'t really work, for several
reasons, discussed below.

Multiple instructions can be generated from a single line so that there
are several instructions with the same line number in the typical case.
The opcodes mapping to a certain line number can also be scattered
around the code (not necessarily in a linear or localized fashion), e.g.
for flow control constructs. Something like the following is entirely
possible, and normal:

    PC      Line
    --      ----

    50      98
    51      99
    52      100   <--
    53      100   <--
    54      100   <--
    55      100   <--
    56      102
    57      103
    58      103
    59      104
    60      105
    61      100   <--

There may also be several PCs which are \"entry points\" for a certain
line number. This happens with e.g. loop constructs.

A breakpoint may also be targeted on a line number which doesn\'t have
any matching bytecode instructions. This can happen trivially when a
breakpoint is assigned to an empty line, but can also happen
non-trivially when the line numbers in the generated bytecode are off by
one or otherwise unintuitive. The expected behavior is often for the
breakpoint to match when we transition to the breakpoint line *or* over
it. There are several difficulties in using this breakpoint rule
however:

-   There are potentially multiple \"next lines\" or \"next opcodes\".
    Consider a breakpoint on an empty line in the middle of a switch
    statement.
-   Using `(prev_line < break_line) AND (curr_line >= break_line)` as
    the rule to trigger a breakpoint works for the most part, but causes
    some unintuitive breakpoint behavior, especially when a breakpoint
    is in a conditional code block which is skipped but not executed.
    See discussion in: <https://github.com/svaarala/duktape/issues/263>.
    (Duktape 1.2.x used this breakpoint rule; the rule was changed in
    Duktape 1.3.x.)

The current rule (Duktape 1.3.x) for breakpoint triggering is:

    (prev_line != break_line) AND (curr_line == break_line)

In other words, a breakpoint is triggered when we transition to the
exact breakpoint line. See discussion in
<https://github.com/svaarala/duktape/issues/263>.

Implementing breakpoints in terms of line transitions (instead of e.g.
PC values) also solves another related issue: once we hit a breakpoint
on a certain line, how to implement \"step into\" / \"step over\"?
Stepping away from the breakpoint line means we need to execute bytecode
instructions until current line changes to a value different than the
breakpoint line. Note that this is not necessarily the next line or even
a higher line number because control flow can maka a jump backwards.

So, right now Duktape implements breakpoints as follows:

-   When one or more breakpoints is active, the bytecode executor enters
    checked execution. In checked execution the bytecode interrupt
    mechanism is invoked before every opcode. Checked execution is
    carefully avoided when at all possible, to ensure breakpoints don\'t
    slow down performance when they don\'t need to.
-   The interrupt mechanism tracks line information (previous line,
    current line) so that it can detect line transitions. This means
    Duktape will do a pc-to-line for every opcode executed. This is
    currently not optimized and will consult the pc-to-line bitstream
    every time; see future work for notes on how this can be improved in
    the future.
-   Breakpoints and stepping are checked when a line transition occurs,
    i.e. when `prev_line != curr_line`.

### Inner functions and breakpoints

A breakpoint should only be active in the innermost function in the
source code. Consider for example:

    1  function foo() {
    2      print('foo 1');
    3      function bar() {
    4          print('bar 1');
    5      }
    6      print('foo 2');
    7      bar();
    8  }
    9  foo();

Suppose execution was currently at line 2, and a breakpoint was added
for line 4. What happens when you single step?

In a naive implementation the executor considers the line 4 breakpoint
to be active for the foo() activation, and when it detects a line
transition from line 2 to line 6, the breakpoint is triggered. Execution
stops at line 6 before printing \"foo 2\".

To avoid this, a breakpoint is always associated (only) with the
innermost function where it appears. This can be quickly detected by
tracking the line range (smallest and largest line number) for each
function. One can then determine active breakpoints for a function FUNC
as follows:

-   If breakpoint has a different filename, reject.
-   If breakpoint has line number is outside FUNC line range, reject.
    (For foo() line range would be 1-8 and for bar() line range would be
    3-5.)
-   Loop through all inner functions IFUNC of FUNC:
    -   If breakpoint line number is inside IFUNC, reject. IFUNC is
        considered to \"capture\" the breakpoint.
-   Accept breakpoint as active for FUNC execution.

### PC and line number handling

In internal book-keeping the PC field of a `duk_activation` refers to
the next instruction to execute. This PC is not always the correct one
to report. Conceptually the previous instruction (PC-1) is sometimes
still being executed while sometimes we\'re in the middle of two
opcodes, having finished execution of PC-1.

The correct PC to use depends on context. For example:

-   In stack traces PC-1 is used for all callstack levels. For
    activations below the callstack top PC-1 is the instruction still
    being executed (it is the call instruction). For callstack top PC-1
    is the \"offending\" instruction.
-   For debugger Status notification PC is used because we\'ve
    conceptually completed PC-1 and are about to execute PC. Breakpoints
    also trigger at PC *before* the opcode at PC is executed. In a
    debugger UI this means that the line highlighted is the next line to
    execute, and hasn\'t been executed yet.
-   For debugger GetCallStack PC-1 is used for all callstack levels
    below the callstack top: as for stack traces, these call
    instructions are still being executed. However, for callstack top PC
    is used to match Status, so that the line reported indicates what
    line will be executed next.

See: <https://github.com/svaarala/duktape/issues/281>.

### Avoid nested message writing

Consider the following scenario:

-   Debug client requests for local variable names and values using a
    hypothetical GetLocalVarsAndValues request.
-   Duktape starts processing the request, streaming out a REP marker,
    followed by variable names and values.
-   One of the variable values is a getter, and the request handler just
    uses a naive read to get the variable value, so that the getter is
    invoked.
-   The getter calls `print()` which gets forwarded to the debug client.
    The `print()` handler writes a notification message containing the
    print data.
-   This notification ends up in the middle of the GetLocalVarsAndValues
    response, corrupting the debug stream.

Such nested debug messages must be avoided at all times. Some ways to
achieve this:

-   If the debug command only deals with a single value (and not a list
    of values), read and coerce any values into safe form before
    streaming out the response.
-   As a general rule favor side effect free debug commands, e.g. read
    values without invoking getters.
-   For unsafe primitives that may have side effects, favor debug
    commands that just handle a single value (instead of an arbitrarily
    long list of values). Such a primitive is easier to implement safely
    because it doesn\'t need to buffer a potentially unlimited list of
    safely obtained values before starting to write out the response.
-   As a concrete example, the GetLocalVarsAndValues could be fixed
    either by:
    a.  Changing it so that it doesn\'t invoke accessors.
    b.  Changing it to return only a list of variable names, and adding
        a separate primitive to get the local variable value
        (GetLocalVar). This primitive can invoke getters, but it must do
        so before it starts to stream out the response. Note that
        request pipelining allows local variables to read in two round
        trips: first read the variable names, then issue reads for every
        variable name in a big set of pipelined requests.

This issue affects various things here and there:

-   If GC is invoked, it might be tempting to emit a GC notification
    from inside mark-and-sweep code. This would be very unsafe because
    GC can easily be invoked by any operation involving the value stack.

## Design goals

This section provides some notes on goals behind the debugger design
(this is not a comprehensive list).

### Quick integration with a custom target

It should be possible integrate debugging support into a custom target
very quickly, e.g. in one day.

-   This should be achievable with the current solution. One needs to
    implement a custom transport into both the target device and
    duk_debug.js and can then use the debugger web UI to debug the
    target.

### Minimize fragmentation of debug solutions

The debugger architecture should ensure that improvements for Duktape
debugging capabilities are shared between users. Ideally debug clients
developed for different environments could be mixed and matched.

-   This is the main reason why a debug protocol is used as the basis of
    the design instead of a debug API. A debug API would mean every user
    would need to define their own debug protocol, which would fragment
    both the debug protocol and, as a consequence, the debug clients.
-   This goal is achieved to a large extent: any debug client should be
    able to talk with any target. However, there may be need to adapt a
    transport mechanism so it\'s not completely automatic.

### Transport neutrality

The debug protocol should be transport neutral to support embedding in
very different environments and communication links (Wi-Fi, Bluetooth,
serial, etc).

-   Concrete solution is to use assume a reliable (TCP-like) byte
    stream, with user code providing the concrete transport.

### Transport bandwidth

The debugger must work with slow transports, e.g. slow serial links.

-   This is the reason a binary protocol is used: it\'s reasonably
    compact with no compression. Compression is a possible solution but
    it is not preferable for very low memory devices (memory overhead).

The debugger must work with high latency transports (hundreds of
milliseconds).

-   This is the reason why request pipelining is used: pipelining allows
    multiple commands to be sent, reducing blocking round trip waits.
-   Pipelining allows debug commands to be built from small, simple
    operations with minimal additional latency (compared to a
    synchronous request/reply model).

### Human readable protocol

It would be nice for the protocol to be human readable, e.g. plain text.

-   This is currently not achieved as the debug protocol is binary.
-   A binary protocol is used at the moment because it is more compact
    and has a smaller code footprint than parsing a text-based protocol.
    Note that such parsing would need to be done without GC impact or
    other side effects so existing ECMAScript mechanisms (like number
    parsing) cannot necessarily be used as is.

### Code footprint

Debugger support should be optional because it has a significant
footprint.

It should be possible to enable debugger support even for very low
memory devices (e.g. 256kB flash).

-   At the moment the additional code footprint for debugger support is
    around 15-20 kB.

### Memory (RAM) footprint and minimal churn

The debugger implementation should consume a minimal amount of RAM on
top of what the debug commands themselves need.

-   Fixed allocations are preferable to variable allocations for low
    memory devices.

Debugger commands should avoid disturbing Duktape internal state. For
instance, if a debug command requested a dump of the Duktape heap, the
command should cause no changes to the heap during serialization of the
response. Concretely this means that:

-   It must be possible to read and write debug messages without doing
    any memory allocations that can cause a GC. This rules out, among
    other things, pushing values on the value stack and interning
    strings. Memory allocations can be done using raw calls to
    allocation callbacks, but it\'s be preferable to be able to avoid
    memory allocations altogether.
-   Note that it is *not* a requirement that all debug commands be
    implemented without side effects. For instance, reading a variable
    may invoke a getter or use some internal mechanisms with side
    effects. The goal is simply that it should be *possible* to write
    some debug commands that are side effect free if that is necessary.

Large and variable sized buffers for parsing inbound messages or
constructing outbound messages should be avoided. These would be very
problematic on low memory devices.

-   This goal is an important reason why the debug protocol uses a
    stream transport. A stream transport allows e.g. the whole heap to
    be serialized with no variable sized output buffering: values are
    simply streamed out during the heap walk with a fixed streaming
    buffers.
-   This goal is also one reason why the debug protocol is binary
    instead of e.g. JSON: JSON parsing would introduce significant
    memory churn if the current parser were used. Adding a separate
    parser for debugging would be wasteful.

### Performance

When a debugger is not attached (but debugger support is compiled in),
performance should be as close to normal as possible.

When a debugger is attached but there are no active breakpoints,
performance should be as close to normal as possible.

Performance with active breakpoints is not critical, but still matters
on slow targets so that timing sensitive applications have a chance of
working properly when debugged.

## Miscellaneous design notes

Some design notes on miscellaneous issues, rejected alternatives, etc.

### Debug commands instead of debug API

Instead of a debug protocol Duktape could provide a set of API
primitives to allow user code to implement a debugger on its own. This
would have several downsides:

-   There would need to be a lot of new public API primitives with deep
    access to Duktape internals. Such an API would be a major
    maintenance issue going forwards: when Duktape internals change,
    there would still be old API promises to keep. A debug protocol can
    hide the internal details more effectively.
-   Every user application with a need for debugging would need to
    implement their own debug protocol: there would be no standard debug
    commands, just raw API calls which can be used to implement a
    debugger. Every Duktape debugger integration would be different.

### Impact of being an embeddable interpreter

Embedded model means there is no standard launch like there is for a JVM
for instance. The debugger needs to connect to a running instance, and
the launching of the instance is up to the user. There may also not be
easy access to source code: the way it is loaded is up to the user, and
some of the source code is given from C code, perhaps programmatically.

It\'s up to the application to decide when the debugger is attached. For
instance, a debugger may attached on startup (some kind of \"reboot and
debug\" mode) or only when debugger is attached at runtime.

### Packet based protocol

The debug transport could be based on delimited debug packets. Both V8
and Spidermonkey debug protocols are (JSON) packet based.

In a packet based protocol an inbound message needs to reside in memory
to be processed. Similarly outbound messages are formed as full packets
before being sent. This works poorly with low memory devices because it
is difficult to limit the maximum debug packet size:

-   For example, even if a debug packet only contained a single string
    (perhaps an eval result), the size of the string may vary widely. If
    debug packets have an upper size limit, it\'s quite easy to get into
    a situation where values that easily fit into memory cannot be sent
    over the debug protocol
-   One can alleviate this problem by doing fragmented reads, i.e. the
    debug protocol allows the debug client to read in a string in
    chunks. This has string life cycle issues, and such a fragmentation
    protocol is in fact emulating a stream transport in a crude way.
-   A similar approach is needed for serializing object values, and
    potentially many other debug commands, which is very awkward from a
    protocol design perspective.

### Stream protocol without request/response framing

The debug protocol could also be a stream protocol with no
request/response framing. This works poorly when either party may
initiate messages without lock step. For example, if debug client sends
a request and the target sends a notification, how can the debug client
know that the bytes it receives are not a response but an unrelated
notification?

Some framing is needed to at least separate responses from other
messages.

### Pipelining vs. asynchronous messages

The current design is to allow pipelining of requests: each request has
a single reply (or error) and requests are never reordered. There is no
need for request/reply identifiers in this model.

Another design would be to allow each party to send responses to
incoming commands in an arbitrary order (asynchronously). This would be
useful if some operations took a long time and could be handled in the
background while more urgent operations could be processed in the
meantime.

In practice this is difficult to implement especially on the debug
target, and would require more state tracking. It would also make it
more difficult to send multiple requests (compared to pipelining)
because there would be no guarantee of their completion order.

### Untyped debug message encoding

One alternative tried was to use untyped encoding for debug messages,
i.e. debug client and target both know what exact data messages are
intended to have, so there is no need to tag a value e.g. as an integer
or a string.

This would be efficient but difficult to extend in a compatible fashion.
Instead, the debug protocol would need hard versioning for every minor
change and the debug client would need to support all protocol variants.
This is not necessarily a showstopper though as the debug client will
need to have version awareness anyway.

### Variable size integer encoding

The debug protocol exchanges a lot of small and large integers. The
extended UTF-8 encoding was used first which is consistent with other
variable length integer encoding in Duktape.

However, when the current tag initial byte (IB) was added, it became
very natural to use the tag byte to encode small integers and to encode
the byte length of larger integers. This representation is actually
quite similar to CBOR: <https://tools.ietf.org/html/rfc7049>.

### Accessors and proxies vs. variable get/set

-   Triggering setters / getters may not be desirable.
-   Perhaps return value like Object.getOwnPropertyDescriptor(), and
    allow debug client to invoke the getter if necessary? (Heap walking
    provides a similar feature now.)
-   Access proxy and target separately?

## Other debugger implementations

### Overview

Both V8 and Spidermonkey use a packet based debug protocol with much of
the protocol formatted in JSON. Although this is quite an intuitive
approach, Duktape uses a stream based binary protocol to avoid the
memory churn related to using JSON, and to better support very low
memory devices where forming complete debug messages in memory would be
problematic.

### Chrome/V8

Chrome/V8 uses a packet based debug protocol where each packet is a JSON
message:

-   <https://code.google.com/p/v8-wiki/wiki/DebuggerProtocol>

Also see:

-   <https://code.google.com/p/chromedevtools/wiki/ChromeDevToolsProtocol>
-   <https://developer.chrome.com/devtools/docs/javascript-debugging>

### Firefox

Mozilla uses a packet based debug protocol where packets are either JSON
or binary blobs. It can be mapped to a stream:

-   <https://wiki.mozilla.org/Remote_Debugging_Protocol_Stream_Transport>

Also see:

-   <https://developer.mozilla.org/en/docs/Debugging_JavaScript>

### Eclipse

An Eclipse debugger could be implemented using the Duktape debugger
protocol. Some resources for that:

-   <http://www.eclipse.org/articles/Article-Launch-Framework/launch.html>
-   <http://www.eclipse.org/articles/Article-Debugger/how-to.html>

## Known issues

### Valgrind uninitialized byte(s) warning

You may get the following when doing a DumpHeap:

    ==17318== Syscall param write(buf) points to uninitialised byte(s)
    ==17318==    at 0x5466700: __write_nocancel (syscall-template.S:81)
    ==17318==    by 0x427ADA: duk_trans_socket_write_cb (duk_trans_socket_unix.c:237)
    ==17318==    by 0x403538: duk_debug_write_bytes.isra.11 (duk_debugger.c:379)
    ==17318==    by 0x4036AC: duk_debug_write_strbuf (duk_debugger.c:463)
    [...]

When unpacked duk_tval is in use, all bytes of a duk_tval are not
necessarily set when a certain value is written into the duk_tval. This
is not a safety issue because Duktape won\'t read or use the
uninitialized bytes in ordinary situations. However, the uninitialized
bytes in the \'data\' area of a compiled function will be written out by
DumpHeap as is, causing the above (harmless) valgrind gripe.

## Future work

### Error handling

Add error handling wrappers to debug code. For instance, if we run out
of memory, detach automatically as a recovery measure?

Currently unsafe behavior may be triggered by internal errors (e.g. out
of memory) or, for instance, a getter error triggered by GetVar.

### Fast pc-to-line for checked execution

During checked execution we need to figure out the line number for the
current PC so that line transitions can be tracked accurately. Right now
the pc-to-line bitstream is consulted statelessly each time, which is
slow (but only affects checked execution, i.e. when there\'s an active
breakpoint for the current function).

There are several ways to make this faster:

-   Cache the pc-to-line conversion state. If the PC increases by one,
    we can almost always just decode a single line delta from the
    bitstream which is very efficient and requires no data format
    changes.
-   When entering checked execution, create an unpacked pc-to-line array
    so that lookups can be done as simple array lookups.
-   When debugging is enabled, store pc-to-line conversion information
    as a plain array in general. This has a memory footprint impact for
    all functions, even when a debugger is not attached (but Duktape
    debugger support is compiled in) so this approach is not very
    desirable.
-   Emit explicit line transition opcodes. This has a memory and
    performance impact, even when a debugger is not attached, so this
    approach is also not very desirable.

### Improve compiler line number accuracy

The ECMAScript compiler assigns line numbers to bytecode opcodes
emitted, and doesn\'t always do a perfect job in doing so. There are a
few cases where the line number for a statement can be off by one
(matching a previous statement) which looks funny in the debugger UI.

The underlying issue is that the compiler emits bytecode opcodes both
when the active token is in the \"previous token\" and the \"current
token\" slot. Expression parsing usually has the active token in the
previous token slot, while statement parsing (especially when parsing
the initial keyword) has the active token in the current token slot.
This needs some reworking to be fixed properly.

### Source code

Source code handling is currently outside of Duktape scope, and we
simply assume that the proper source file can be located based on a
\"fileName\" property of a running function.

There are many future options:

-   Download from target device (same as where code was originally
    loaded)
-   Store source when compiling in debug mode, possibly using some
    trivial compression to reduce the memory impact
-   Identify source code text using a hash computed on the target, so
    that the corresponding source can be located more reliably

### Source maps

It\'s a common practice to minify Javascript code. Line number
information is often lost in the process, and this makes the code
difficult to debug for a variety of reasons:

-   Source code readability is poor
-   Breakpoint mechanisms targeting file/line work very poorly

Source maps record the original line number information:

-   <http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/>

If Duktape supported source maps, a source map could be taken into
account during compilation and function pc-to-line mapping could refer
to the original unminified source code which would be much more debugger
friendly.

### More flexible pausing

Various triggers for pausing could be added:

-   Pause on function entry/exit
-   Pause on next statement
-   Pause on yield/resume
-   Pause on execution timeout

### More flexible stepping

Additional stepping parameters could be implemented:

-   Step one PC at a time
-   Step for N bytecode instructions
-   Step for roughly N milliseconds

### Dynamically declared variables in local variable list

The local variable list returned by GetLocals does not include
dynamically declared variables, or variables with a scope smaller than
the entire function:

    function test() {
        var foo = 123;   // 'foo' is included

        eval('var bar = 321');  // 'bar' is not included

        try {
            throw 'foo';
        } catch (e) {
            // 'e' is not included
        }
    }

This should be fixed so that the locals include dynamic variables too.
This is especially important for try-catch.

The Eval command can read/write dynamic variables too, so the current
workaround is to use Eval. For instance, in the catch clause, Eval `"e"`
to read the error caught.

### Expression dependent breakpoints

Pause when an expression evaluates to a truthy value.

### Watch expressions

Watch expressions are currently implemented by the debug client using
the Eval command.

For example, the debugger web UI implements automatic eval for a single
expression. The expression is automatically evaluated when Duktape
becomes paused. This is easy to extend for multiple watch expressions.

### Notifications on internal events

Send a notification when interesting internal events occur, like:

-   Ordinary GC
-   Emergency GC
-   Thread creation
-   Thread destruction
-   Execution timeout

These must be implemented very carefully. For instance, if we\'re
currently in the process of responding to some debug command (say, \"get
locals\") and GC is triggered, the GC notify cannot be sent inline from
the mark-and-sweep code because it might then appear in the middle of
the \"get locals\" response. Instead, events need to be flagged, based
on counters, or queued.

### Possible new commands or command improvements

-   More comprehensive callstack inspection, at least on par with what a
    stack trace provides
-   Resume with error, i.e. inject error
-   Enumerate threads in heap
-   Enumerate all objects in heap
-   Status for success/failure of PutVar
-   Error handling for PutVar
-   Avoid side effects (getter invocation) in GetVar

### Direct support for structured values

The current mapping between `duk_tval` values and dvalues works but it
cannot represent structured types. For instance, if a hypothetical debug
command to set a global variable reads the value argument as a dvalue,
it cannot write a value like `[1,2,3]` into the global variable.

This can of course be worked out by doing an `eval()` for the argument
or by representing the value as JSON (which is more or less the same
thing).

Another alternative is to add support for representing structured values
directly with dvalues, so that when C code does a:

    duk_debug_read_tval(thr);

an arbitrarily complex object value (perhaps even an arbitrary object
graph) can be decoded and pushed to the value stack.

Heap walking support alleviates this problem for the cases where the
structured data resides or can be placed in the Duktape heap.

### Heap dump viewer

The DumpHeap command provides a snapshot of all heap objects, which the
debugger web UI converts into a JSON dump. It\'d be nice to include a
viewer for the dump, so that it\'d be easy to traverse the object graph,
look for strings and values, etc.

### Eclipse debugger

An Eclipse debugger would be very useful as it\'s a very popular IDE for
embedded development. There are already integrations for Visual Studio
Code.

### Breakpoint handling in attach/detach

Currently the list of breakpoints is not cleared by attach or detach, so
if you detach and then re-attach, old breakpoints are still set. The
debug client can just delete all breakpoints on attach, but it\'d be
cleaner to remove the breakpoints on either attach or detach.

### Indicate fastint status

When debugging code that is intended to operate with fastints, it would
be useful to see when a value is internally represented as a fastint vs.
a full IEEE double. Currently this information is not conveyed by the
protocol, and all fastints appear like any other number values.

### Buffer object support

Make it easier to see buffer object contents (like for plain buffers),
either by serializing them differently, or through heap walking.

### Separate callback for checking transport status

When Duktape is in the running state (not paused), Duktape will only
call:

-   The peek callback periodically to see if there is anything to read.
    There\'s no way to indicate a transport detach/error with peek now.
-   The write callback periodically, as a side effect of sending Status
    notifies. This is the main mechanism now for detecting a broken
    transport in the running state. If Status notifies were removed,
    Duktape would not notice a transport break unless something else
    prompted a write to the debug transport.

It might be cleaner to provide either:

-   A callback to check transport status explicitly and perhaps allows
    even an error message to be indicated.
-   Allow user code to proactively call into Duktape to indicate the
    transport is broken (beyond calling `duk_debugger_detach()`).

However, for some transports it may not be possible to get transport
status information without actually attempting a write. This may be
caused by the nature of the transport or an underlying platform API
limitation, for example. So, such a transport status callback must be
optional, and it may still be necessary to ensure a periodic write (a
\"keepalive\" if nothing else) to detect transport errors in such cases.

### Extend ERR message with a programmatic string error code

Current error messages have the form:

    ERR <error number> <message> EOM

The number space is awkward to manage modularly, and doesn\'t work well
for application specific errors which would be useful for e.g.
AppRequest messages. Extend the error format to:

    ERR <error number> <error string code> <message> EOM

String codes could follow an all caps convention like `"NOT_FOUND"`:

    ERR 3 "NOT_FOUND" "breakpoint not found" EOM

String error codes are easy to extend without conflicts like one has
with a numbered sequence.

### Change callstack entries to avoid getter invocations

With heap walking in place callstack variable dump could provide the
necessary information to distinguish data and accessor properties and
let the debug client decide if getters are to be invoked.

Callstack primitives could also return the variable list in a format
matching the GetHeapObjInfo command, i.e. as a key/value list which also
provides support for artificial properties and property flags.

### Replace GetBytecode with object inspection

The GetBytecode command could be removed by providing a reference to the
current function and then using object inspection to get the bytecode
data currently returned in GetBytecode \-- that is, the bytecode,
constants, etc.

### Improve garbage collection behavior during paused state

Current behavior: garbage generated during paused state (refzero or
objects in reference loops) will both be left in the heap and collected
eventually by mark-and-sweep.

Various improvements are possible, see discussion in
<https://github.com/svaarala/duktape/pull/617>.
