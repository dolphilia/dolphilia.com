## duk_check_stack() 

1.0.0 stack

### プロトタイプ

```c
duk_bool_t duk_check_stack(duk_context *ctx, duk_idx_t extra);
```

### スタック

(バリュースタックに影響なし。)


### 要約

バリュースタックに、呼び出し元が使用するために、現在のスタックの先頭から相対的に、少なくとも余分な予約（割り当て）要素があることを確認します。成功すれば1を、そうでなければ0を返す。呼び出しが成功した場合、呼び出し元は、バリュースタック関連のエラーなしに、追加の要素をバリュースタックにプッシュできることが保証される（メモリ不足などの他のエラーはまだ発生する可能性がある）。呼び出し元は、余分な値をプッシュできることに依存してはならない（MUST NOT）。

Duktape/C関数に入る時、そして呼び出しの外では、バリュースタックの呼び出し引数に加え、呼び出し側のために（DUK_API_ENTRY_STACK要素の）自動的な予備が確保されています。より多くのバリュースタックスペースが必要な場合、呼び出し側は関数の最初（例えば、必要な要素数が既知であるか、引数に基づいて計算できる場合）または動的（例えば、ループ内）に明示的に多くのスペースを予約しなければなりません。現在割り当てられているバリュースタックを越えて値をプッシュしようとするとエラーになることに注意してください．これは，内部実装を簡略化するためである．

Duktapeは、ユーザー予約要素に加えて、全てのAPIコールが更なる割り当てをせずに動作するのに十分なバリュースタック空間を確保するために、自動的に内部バリュースタック予備を保持します。また、メモリ再割り当ての動作を最小限に抑えるため、バリュースタックはある程度大きなステップで拡張されます。その結果、呼び出し元が指定した余分な値を超えて利用可能なバリュースタック要素の内部数は、かなり変化します。呼び出し元はこれを考慮する必要はなく、利用可能な追加要素に依存するべきでは決してない。

一般的なルールとして、より多くのスタックスペースを確保するために、この関数の代わりに duk_require_stack() が使用されるべきです。バリュースタックを拡張できない場合、エラーを投げて巻き戻す以外に、有用な回復方法はほとんどありません。


### 例

```c
duk_idx_t nargs = duk_get_top(ctx);  /* number or arguments */

/* reserve space for one temporary for each input argument */
if (!duk_check_stack(ctx, nargs)) {
    /* return 'undefined' if cannot allocate space */
    printf("failed to reserve enough stack space\n");
    return 0;
}

/* ... */
```

### 参照

duk_require_stack