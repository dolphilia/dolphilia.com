## duk_put_prop() 

1.0.0 property

### プロトタイプ

```c
duk_bool_t duk_put_prop(duk_context *ctx, duk_idx_t obj_idx);
```

### スタック

| ... | obj | ... | key | val | -> | ... | obj | ... |

### 要約

obj_idx にある値のプロパティキーに val を書き込む。 key と val はスタックから削除されます。リターンコードとエラースローの動作

プロパティの書き込みに成功した場合、1を返す。
書き込みに失敗した場合、エラーを投げます。（ストリクトモードセマンティクス）。また、アクセッサプロパティのセッタ関数によってもエラーがスローされる場合があります。
obj_idx の値がオブジェクト互換でない場合、エラーを投げます。。
obj_idx が無効な場合、エラーを投げます。。
プロパティの書き込みは、ECMAScript の式 obj[key] = val と等価です。プロパティ書き込みが成功または失敗するときの正確なルールは、同等の代入を行う ECMAScript コードと同じです。正確なセマンティクスは、プロパティアクセサ、PutValue (V, W)、および [[Put]] (P, V, Throw) を参照してください。ターゲット値とキーは共に強制されます。

ターゲット値は自動的にオブジェクトに強制されます。しかし、オブジェクトは一過性のものなので、そのプロパティを書いてもあまり意味がない。さらに、ECMAScript のセマンティクスはそのような一時的なオブジェクトのために新しいプロパティを作成することを防ぎます（特別な [[Put]] バリアントのステップ 7、PutValue (V, W) を参照）。
キー引数は内部的に文字列または Symbol になる ToPropertyKey() 強制適用を使用して強制適用されます。配列と数値インデックスには、明示的な文字列強制を避ける内部高速パスがあるので、該当する場合は数値キーを使用してください。
ターゲットがセットトラップを実装するProxyオブジェクトである場合、トラップが呼び出され、APIコールの戻り値はトラップの戻り値に一致します。

ECMAScript では、代入式は、代入の成功の有無にかかわらず、右辺の式の値を持つ。この API コールの戻り値は、ECMAScript によって指定されておらず、ECMAScript コードで利用可能でもありません。API コールは、割り当てが成功したかどうかに応じて 0 または 1 を返します (厳格なコードでは 0 の戻り値がエラーに昇格します)。
キーが固定文字列である場合、1 つの API 呼び出しを回避して、 duk_put_prop_string() 変数を使用することができます。同様に、キーが配列のインデックスである場合、 duk_put_prop_index() 変数を使用することができます。

プロパティアクセスの基本値は通常オブジェクトですが、技術的には任意の値にすることができます。普通の文字列やバッファの値には仮想的なインデックスプロパティがあり、例えば "foo"[2] にアクセスすることができます。また、ほとんどのプリミティブな値は何らかのプロトタイプオブジェクトを継承しているので、例えば (12345).toString(16) のようにメソッドを呼び出すことができます。

### 例

```c
duk_bool_t rc;

duk_push_string(ctx, "key");
duk_push_string(ctx, "value");
rc = duk_put_prop(ctx, -3);
printf("rc=%d\n", (int) rc);
```

### 参照

duk_put_prop_index
duk_put_prop_string
duk_put_prop_lstring
duk_put_prop_literal
duk_put_prop_heapptr