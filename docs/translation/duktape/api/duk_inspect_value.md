## duk_inspect_value() 

2.0.0 stack inspect

### プロトタイプ

```c
void duk_inspect_value(duk_context *ctx, duk_idx_t idx);
```

### スタック

| ... | val | ... | -> | ... | val | ... | info |

### 要約

idxの値を検査し、そのオブジェクトに関するDuktape固有の内部情報を含む オブジェクトをプッシュします。バリュースタック・インデックスが無効な場合、"none "値を記述したオブジェクトをプッシュします。

結果オブジェクトはバージョン保証の対象外なので、そのプロパティはマイナー・リリースでも変更される可能性があります（パッチ・リリースは不可）。これは現実的な妥協点です。内部はかなり頻繁に変更されるので、バージョニングを保証しないか、内部を全く公開しないかのどちらかを選択することになります。そのため、呼び出し側のコードは、特定のフィールドのセットが利用可能であることに依存してはいけませんし、結果フィールドを解釈する際にDUK_VERSIONをチェックする必要があるかもしれません。
次の表は、現在のプロパティをまとめたものです。メモリのバイトサイズにはヒープオーバーヘッドは含まれておらず、使用するアロケーション関数によって0〜16バイト(またはそれ以上)の間で変化する可能性があります。

プロパティ 説明
type duktape.hのDUK_TYPE_xxxにマッチするタイプ番号。
itag 内部 DUK_TAG_xxx の定義にマッチする内部型タグ。値はバージョン間で変更される可能性があり、設定オプションと、内部でタグ付けされた値に使用されるメモリレイアウトに依存します。
hptr ヒープで割り当てられた値のためのヒープ・ポインタ。値のタイプに関連するDuktape内部ヘッダー構造体を指す。同じ値が duk_get_heapptr() から返されます。
refc 参照カウント。参照カウントは一切調整されず、duk_inspect_value()コールによる値への参照も含まれます。
class オブジェクトの場合、内部クラス番号、内部 DUK_HOBJECT_CLASS_xxx の定義に一致します。
hbytes メインヒープオブジェクトの割り当てのバイトサイズ。いくつかの値では、これが唯一の割り当てであり、他の値では追加の割り当てがあります。
pbytes オブジェクトのプロパティテーブルのバイトサイズ。プロパティテーブルには、配列部分、ハッシュ部分、およびキー/値エントリ部分が含まれる可能性があります。
bcbytes ECMAScript の関数バイトコード（命令、定数）のバイトサイズ。ある関数テンプレートの全インスタンス（クロージャ）間で共有されます。
dbytes ダイナミックバッファまたは外部バッファの現在の割り当てのバイトサイズ。外部バッファーの割り当ては、Duktapeのヒープの一部ではないことに注意してください。
esize オブジェクト・エントリ部分のサイズ（要素数）。
enext オブジェクト・エントリ部の最初の空きインデックス（＝次に使用されるプロパ ティ・スロットのインデックス）。実際には、圧縮されていない削除されたキーを持たないオブジェクトのための独自のプロパティの数に一致します。
asize オブジェクトの配列部分のサイズを要素数で表し、配列部分がない場合や配列部分が放棄されている場合（疎な配列）には 0 となります。見かけ上の配列の長さよりも大きくても小さくてもかまいません。
hsize 要素数で表したオブジェクトハッシュ部のサイズ。
tstate 内部スレッド状態、内部の DUK_HTHREAD_STATE_xxx の定義にマッチします。
variant 特定の型に対する型バリアントを識別します。文字列の場合、variant 0 は通常のヒープに割り当てられた文字列で、variant 1 は外部文字列です。バッファの場合、variant 0 は固定バッファ、1 は動的バッファ、2 は外部バッファです。

### 例

```c
duk_inspect_value(ctx, -3);
duk_get_prop_string(ctx, -1, "refc");
printf("refcount of value at -3: %ld\n", (long) duk_to_int(ctx, -1));
duk_pop_2(ctx);
```