
## コルーチン {#coroutines}

Duktapeは、単純なコルーチンをサポートしています。コルーチン A はコルーチン B を再開または開始し、コルーチン B は降伏または終了（成功またはキャッチされないエラー）するまで実行し、その後コルーチン A は降伏結果で実行を継続します。

コルーチンは new Duktape.Thread() で作成され、その唯一の引数は、新しいコルーチンが最初のレジュームで実行を開始する初期関数として取得します。レジューム引数は、初期関数の最初の（そして唯一の）引数値となります。

Duktape.Thread.resume()は、再開するコルーチン、再開値、（オプションで）再開値が通常の値か、対象のコルーチンに注入されるエラーであるかを示すフラグを引数にとります。エラー投入とは、レジューム値をターゲットコルーチンの最後のyield操作の場所で "throw "することを意味します。つまり、通常の値で戻るのではなく、一見、エラーを投げるように見える。

Duktape.Thread.yield()は、yieldする値と、（オプションで）yield値が通常の値であるか、再開するコルーチンのコンテキストで投げられるエラーであるかを示すフラグを引数として取ります。言い換えれば、エラー値を指定すると、レジューム操作で通常の値を返す代わりにエラーを投げるように見える。

コルーチンが正常に存在する場合、すなわち、初期関数が値を返して終了する場合は、戻り値でyieldと同様に処理される。捕捉されないエラーによってコルーチンが存在する場合、それはエラーを伴うyieldと同様に扱われる：再開操作は、再開するコルーチンのコンテキストでそのエラーを再スローする。いずれの場合も、終了したコルーチンはもはや再開することができません; 再開しようとするとTypeErrorが発生します。

現在、yield が可能な場合、厳しい制限がある。つまり、コルーチンのアクティブなコールスタック全体が ECMAScript から ECMAScript への呼び出しで構成されている場合のみ、降伏が可能です。以下のものは、降伏するコルーチンのコールスタックのどこかに存在する場合、降伏を防ぎます。

- Duktape/C関数呼び出し
- ゲッター/セッター呼び出し
- プロキシ・トラップ呼び出し
- eval() 呼び出し
- ファイナライザー呼び出し

> Duktape 2.2以降、コンストラクタ呼び出し（new Func()）、Function.prototype.call()、 Function.prototype.apply() 、 Reflect.apply() 、 Reflect.construct() は yield を防止しなくなった。

例として、コルーチンの使い方を参照してください。

